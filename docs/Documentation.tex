\documentclass[12pt,             % Schriftgroesse
               a4paper,          % Papierformat
               %liststotoc,      % (alt) Tabellen- und Abbildungsverzeichnis im Inhaltsverz.
               listof=totoc,     % Tabellen- und Abbildungsverzeichnis im Inhaltsverz.
               %idxtotoc,        % (alt) Index im Inhaltsverz. auffuehren
               index=totoc,      % Index im Inhaltsverz. auffuehren
               %bibtotoc,        % (alt) Literaturverzeichnis im Inhaltsverz. auffuehren
               bibliography=totoc,% Literaturverzeichnis im Inhaltsverz. auffuehren
               oneside,         % auskommentieren, wenn beidseitig gedruckt wird
                                 % default ist 'twoside'
               BCOR1cm,          % zusaetzlicher Bindungsrand
               english   %  Englisch als weitere Sprache, Deutsch als Hauptsprache
               ]{scrbook}

\usepackage[utf8]{inputenc}  
\usepackage[T1]{fontenc}
\usepackage{lmodern}         
%\usepackage{eurosym}  
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage[left=20mm, right=20mm, top=25mm]{geometry}
\usepackage{listings} \lstset{numbers=left, numberstyle=\tiny, numbersep=5pt, basicstyle =\footnotesize\ttfamily, showspaces=false, showstringspaces=false} 
\lstset{language=ruby}
\usepackage{url}
\setlength\parindent{0pt} 
\usepackage{float}

\usepackage{hyperref}
\linespread{1.3}
\usepackage{multicol}
\usepackage[german]{varioref}

\usepackage{pdfpages}

\bibliographystyle{alphadin}

\setcounter{tocdepth}{1}

\usepackage[]{acronym}

\title{Testdriven Development am Beispiel der o/zb Webapplikation}
\author{Martin Briewig, Michael Leibel}


\begin{document}

\pagestyle{empty}
\begin{center}

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.70\textwidth]{\string"Media/hskalogo\string".jpg}
	\end{center}
	\label{fig:hska_logo}
\end{figure} 

\vspace{5\baselineskip}

\textsc{\Huge Test-Driven Development\\ mit Ruby on Rails}\\[0.25cm]
\textsc{\large am Beispiel der o/ZB Webapplikation}\\[1.5cm]


\vspace{2\baselineskip}

\textsc{\LARGE Projektarbeit}\\[1.5cm]


\vspace{5\baselineskip}

vorgelegt von\\
Briewig, Martin, B.Sc. (Matr.-Nr.: 43509)\\
Leibel, Michael, B.Sc. (Matr.-Nr.: 43674)

\vspace{\baselineskip}

Betreuer: Prof. Dr. Frank Schaefer

Fachbereich: Informatik (Master)
\end{center}

\clearpage{}

\pagenumbering{roman} 

\tableofcontents{}

\clearpage{}

%\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
\chapter*{Abkürzungsverzeichnis}

\begin{acronym}[SQL]
	\acro{AP}{Arbeitspaket}
	\acro{o/ZB}{Ohne Zins Bewegung}
     \acro{RoR}{Ruby on Rails}
     \acro{SSH}{Secure Shell}
\end{acronym}

\newpage

\pagenumbering{arabic} 
\chapter{Einleitung}
Die ohne Zins Bewegung Stuttgart arbeitet nun seit einigen Jahren mit der Hochschule Karlsruhe zusammen an einer Webanwendung. Diese Webanwendung soll die Geschäftsprozesse der Bewegung unterstützen und verwalten. Im Laufe der letzten Jahre ist aus der ursprünglichen Idee eine komplexe Webanwendung entstanden, die nun gründlich auf Fehler überprüft und gegebenfalls ausgebessert werden soll. 
Diese Aufgabe wird nun uns, Herr Briewig und Herr Leibel, anvertraut. Im Folgenden wird eine detaillierte Aufgabenstellung formuliert, an dieser sich diese Projektarbeit messen lassen wird.  

\section{Aufgabenbeschreibung}
Die Aufgaben dieser Projektarbeit sind recht vielfältig. Sie lassen sich in 4 Phasen einteilen. Die Aufgaben pro Phase wurden maßgeblich von den Meetings geprägt.

\subsection{Phase 1: Korrekturen, Dokumentieren}
\textbf {(Duedate: 02.05.2013)}\\
% Korrekturen am ER Diagramm/Relationenmodell
%    -    ER Diagramm soll der Implementierung entsprichen
%    -    Darstellung aller PKs und FKs für den nicht historisierten Fall
Die erste Phase wird von den Korrekturen am ER-Diagramm und dem dazugehörigen Relationsmodell dominiert. Das ER-Diagramm weißt noch ein paar Unstimmigkeiten auf, die im Laufe der Zeit entstanden sind. Diese gilt es zu bereinigen und die vorgenommenen Korrekturen in der Implementierung umzusetzen. Ziel ist ein ER-Diagramm, dessen Entitäts-Beziehungen den nicht-historisierten Zustand darstellen. Dieses ER-Diagramm soll 1:1 in der Implementierung vorzufinden zu sein. Es soll vereinfacht dargestellt werden, lediglich die Primär- und Fremdschlüssel, die im historisierten Zustand gültig sind, sollen den Entitäten als Zusatzinformationen dienen.\\

% Dokumentieren:
%    -    DB-Migration, wie geht das?
%    -    Deployment, wie funktioniert das?
Neben den Korrekturen am ER-Diagramm sind Dokumentationen der Vorgehens- und Funktionsweise des Datenbank Migrationstools notwendig. Hierfür sind zwei Batch-Skripte angefertigt worden, deren Nutzungs- und Funktionsweisen zu dokumentieren sind.\\

Im Laufe der Zeit sind die verschiedensten Techniken zur Bereitstellung und Versionierung der o/zb Webanwendung verwendet worden. Es gilt nun, einen einheitlichen Vorgang zu definieren der für die nachfolgenden Projektgruppen verwendet werden soll. Basierend auf der anzufertigten Dokumentation, kann die Bereitstellung und Versionierung stetig verbessert werden.\\

% Allgemeine Korrekturen:
%    -    WebImport
Zusätzlich soll in dieser Phase ein kritischer Fehler bereinigt werden. Der WebImport, welcher für den Import der Kontobewegungen verantwortlich ist, arbeitet nicht richtig. Zur Zeit ist der Datei-Upload auf dem Testsystem nicht möglich. Darüber hinaus kommt es bei einer lokalen Testumgebung zu Laufzeitfehlern. Auch die im Webfrontend angezeigte Anzahl der importierten Datensätze ist nicht korrekt.

\subsection{Phase 2: Korrektur der Darlehensverlaufsanzeige}
\textbf {(Duedate: 23.05.2013)}\\
% Allgemeine Korrekturen:
%    -    Korrektur der Punkteberechnung
In der zweiten Phase soll das Hauptaugenmerk auf die Korrektur der Darlehensverlaufsanzeige gelegt werden. Diese Anzeige gilt als einer der Kerngeschäftsprozesse. Hier wird der Buchungsverlauf über einen, vom Benutzer festgelegten, Zeitraum dargestellt. Dabei ist es wichtig, die korrekten Punkte- und Währungs-Saldi zu berechnen. Dies funktioniert in der aktuellen Version nicht korrekt. Daher gilt es, die Fehler auszumerzen.  


\subsection{Phase 3: Einrichtung Testdriven Development, Erstellung der Model Tests}
\textbf {(Duedate: 13.06.2013)}
% Tests
%    -    Beschreibung der Testumgebung mit Sublime 2(?) und RSpec
%    -    Testfälle entwickeln
% Feature:
%    -    Dokumente (Word,PDF) generieren

Dies Phase steht im Zeichen der Einführung der Testgetriebenen Entwicklung (\glqq Testdriven Development\grqq). In der Vergangenheit ist die Webanwendung stark gewachsenen, es sind immer häufiger Fehler und Inkonsistenzen aufegfallen. Ziel ist es nun der Anwendung, mit Hilfe von Tests, zu einem konsistenten und möglichst fehlerlosen Zustand zu verhelfen. Auch sollen die Tests helfen, sich einen genaueren Überblick über den Zustand der Webanwendung zu verschaffen. Für eine erfolgreiche und effiziente Test-Entwicklung, ist eine gute Auswahl der Tools unabdingbar. Der Gebrauch dieser Tools soll auch festgehalten werden.

\subsection{Phase 4: Datenmodellkorrekturen, Implementierung Integrationtests}
\textbf {(Duedate: 11.09.2013)}
Nachdem sich ein detaillierter Überblick über den Zustand der Webanwendung verschafft worden ist, wird das Datenmodell festgelegt, implementiert und erneut getestet. Ist dies abgeschlossen, werden beispielhafte Integrationstest implementiert und dokumentiert. Diese dienen dann den Nachfolgern als Anhaltspunkt für den weiteren Werdegang dieser Webanwendung. Außerdem werden grobe Fehler in der Webanwendung behoben.


\clearpage
\chapter{Hintergrundwissen}
\section{Das o/ZB Projekt}
Die Solidargemeinschaft o/ZB Stuttgart wurde am 21. Januar 2005 als GbR von 10 GesellschafterInnen gegründet und hatte Mitte des Jahres bereits 100 Mitglieder.
Die o/ZB ist ein regionales Finanzierungsinstrument, das seinen Mitgliedern die Realisierung von Projekten in Selbsthilfe ermöglicht. Anderst als bei klassischen Einrichtungen erfolgen alle Einlagen (z.B. Sparen) und Entnahmen (z.B. Leihen) zinslos und kostenfrei, weil alle anfallenden Arbeiten von ihren Mitgliedern in Selbstverwaltung ausgeführt werden können.

Abbildung \vref{fig:ozb_process} zeigt das von der o/ZB verwendete Dreiphasenkonzept.
\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.65\textwidth]{\string"Media/3PhasenKonzept\string".png}
     \end{center}
     \label{fig:ozb_process}
     \caption{o/ZB Dreiphasenkonzept}
\end{figure} 


\section{Das Testsystem}\label{sec:Das_Testsystem}
% URL, Maschine, Versionen... 
Das Testsystem wird von Alvotech betrieben. Das Kundeninterface ist unter der URL \url{http://www.alvotech.de/kundenlogin} erreichbar. Das Testsytem bietet ein Debian GNU/Linux System, Kernelversion 3.1.2. Darüber hinaus ist ein MySQL Server in der Version 5.1.49-3 installiert. Auch Ruby ist in der Version 1.9.3p392 vorinstalliert.\\
Die Webanwendung liegt im Homeverzeichnis. Durch die Einführung von Capistrano geschieht eine Versionierung der Webanwendung. Ein Symlink \textit{ozbapp} führt aus dem Homeverzeichnis zu der aktuellen Version der Webanwendung. Der Web- und Application Server, der für die Ausführung der Webanwendung zuständig ist, heißt \textit{Phusion Passenger} und wird in der Version 3.0.19 verwendet (s. \url{https://www.phusionpassenger.com/}). Die Webanwendung ist unter der URL \url{http://ozbapp.mooo.com/} erreichbar. Der Code liegt in einem Git Repository auf GitHub (\url{https://github.com/Avenel/FirstApp}). Details zu den einzeln genannten Softwaretechnologien können dem Kapitel \ref{sec:deployment} entnommen werden.


\section{Test-Driven Development}
\subsection{Definition}
\textit{Test-driven Development} (eng. für \glqq Testgetriebene Entwicklung\grqq) ist eine Entwicklungsmethode die besonders in Unternehmen, die agile Softwareentwicklungsmethoden anwenden, zu Hause ist. Der Entwicklungsprozess ist recht klein gehalten und verfolgt einen festen definierten Ablauf. Der Ablauf sieht vor, dass zunächst der Test für eine gewünschte Funktionalität geschrieben wird und im Anschluss daran wird der Programmcode geschrieben, der dafür sorgen soll das der Test korrekt abgeschlossen wird. Die nachfolgende Figur \vref{fig:tdd_process} zeigt den gewünschten Ablauf noch einmal im Detail.

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.65\textwidth]{\string"Media/Test-driven_development\string".png}
     \end{center}
     \label{fig:tdd_process}
     \caption{Testdriven Development Prozess}
\end{figure} 

Diese Entwicklungsmethode stiftet die Programmierer dazu an, sehr schlanken (engl. \glqq dry\grqq) Programmcode zu schreiben und einen anderen Blick auf die Anwendung zu erhalten. Darüber hinaus steigert es während der Entwicklungsphase das Selbstbewusstsein des Programmieres, denn er kann mit Hilfe der Tests den Zustand der Anwendung schnell überblicken und sich sicher sein das sein Programmcode funktioniert - auch wenn der Umfang der Anwendung ansteigt. Außerdem steigert diese Entwicklungsmethode die Code-Qualität enorm und führt zu einer Steigerung der Produktivität des Entwicklerteams.\\

Es gibt verschiedene Arten von Tests, die auf verschiedenen Ebenen agieren. In den nachfolgenden Abschnitten werden diese kurz dargestellt und in einen Zusammenhang gebracht. Dabei wird auf die Vorgehensweise bei einer Ruby on Rails Webanwendung Rücksicht genommen. 

\subsection{Modul Tests}
\textit{Modul Tests}, oder auch \textit{Unit Tests}, sind Tests die die einzelnen Komponenten, bzw. Entitäten einer Anwendung testen. Das Ziel dieser Tests ist es, die sowohl fachliche als auch technische korrekte Funktionalität sicherzustellen. Die Tests stellen einen Vertrag dar, die das zu testende Modul erfüllen muss. Diese Testart ist ganz nach vorn im Testprozess einzuordnen und ist die Voraussetzung dafür um mit den Controller Tests fortfahren zu können. Ein Modul ist somit die kleinst zu testendende Einheit in einer Anwendung. Ein Modul Test soll sicherstellen, dass jedes kleine Teil eines Ganzen für sich allein gesehen korrekt funktioniert, sodass das eine Anwendung auf einer soliden Basis aufbauen kann. Bei der Implementierung eines Modul Tests ist zu beachten, dass das zu testende Modul isoliert getestet wird. D.h. es dürfen keine Modulübergreifende Interaktionen implementiert werden. Außerdem testen Modul Tests gemäß des \glqq Design-by-Contract\grqq Prinzips nicht die interne Umsetzung des Moduls, sondern ihre Ausgaben bei verschiedenen Eingaben.

\subsection{Controller Tests}
Der nächste Schritt besteht darin, die Funktionen eines Controllers zu testen. Ein \glqq Controller Test\grqq ist im Grunde nicht viel anders als ein Modul Test, allerdings werden hierbei auch die Interaktionen der verschiedenen Module untereinander getestet, falls der Controller dies leisten soll. Das Ziel ist die Sicherstellung, dass bei fest definierten Benutzereingaben die gewünschte Reaktion geschieht. Auch bei einem Controller Test werden alle Funktionen isoliert getestet. In der Testhierarchie besetzt der Controller Test die mittlere Position, zwischen den Modul Tests und den nun dargestellten Feature Tests.


\subsection{Feature Tests}
Ein sogenannter \glqq Feature Test\grqq ist in etwa vergleichbar mit einem \glqq Integration Test\grqq. Der Feature Test überprüft das Zusammenspiel der verschiedenen Controller. Darüber hinaus werden Testszenarien festgelegt, in denen reale Benutzerinteraktionen beschrieben werden um zu sehen wie die Webanwendung auf diese reagiert. Somit können die Interaktionen eines Benutzers mit der Webanwendung vollständig nachvollzogen werden. Die Benutzerinteraktionen werden vom Testsystem emuliert und generieren Benutzereingaben, die von den Controllern verarbeitet werden. Hier zeigt sich der Unterschied zu den vorher vorgestellten Controller Tests, denn dort sind die Eingaben bereits festgelegt. Mit Hilfe der Feature Tests können somit weite Bereiche einer Webanwendung getestet werden und sind u.a. ein beliebtes Hilfsmittel um bei Bug-Reports ein Testszenario zu beschreiben.

\clearpage
\chapter{Allgemeine Dokumentationen}
\section{Das korrigierte ER-Diagramm}

Das Entity Relationship Diagramm (s. \vref{fig:er_diagramm}) wurde hauptsächlich aus fachlicher Sicht gestaltet. Es repräsentiert die nicht-historisierte Assoziation zwischen den Entitäten. Entitäten, welche historisiert werden, beinhalten als Attribut \glqq GÜLTIG VON\grqq. Der bzw. die Primary Keys sind \underline{unterstrichen} Dargestellt. Die Foreign Keys hingegen werden nach ihrem Attributnamen mit \glqq (FK)\grqq\ gekennzeichnet. 

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=\textwidth]{Media/er_diagramm.pdf}
     \end{center}
     \caption{Entity Relationship Diagramm}
     \label{fig:er_diagramm}
\end{figure} 

%[Insert content, Micha]
% Wie sieht es aus?
% Was wurde angepasst?
% Beschreibung der Veränderungen am Code

\section{Das korrigierte Relationenmodell}
Während der Anfertigung der Unit-Tests ist aufgefallen, dass nicht alle Attribute in ihrer Gültigkeit spezifiziert worden sind. Aufgrund dessen mussten die o/ZB-Attribute überprüft werden und dementsprechend angepasst werden. Ebenso ergaben sich durch Änderungen am ER-Diagramm, Änderungen am Relationenmodell. Die Liste, der gemeinsamen Ausarbeitung aus dem Meeting vom 19.07.2013, befindet sich im Anhang (s. \vref{chapter:ozb_attribute}).

\section{Deployment und Versionskontrolle}
In diesem Abschnitt werden die Begriffe \textit{Deployment} und \textit{Versionskontrolle} erläutert. In jedem Teilabschnitt wird die aktuelle Umsetzung beschrieben. Der letzte Teil dieses Abschnitts beschäftigt sich mit dem \textit{Commit \& Deployment Workflow}.

\subsection{Deployment}\label{sec:deployment}
% Was ist das? Deployment - Capistrano, Versionskontrolle - Git
In der Softwareentwicklung wird unter dem Begriff \textit{Deployment} der Prozess zur \textit{Bereitstellung} und \textit{Verteilung} einer Software verstanden. Der Prozess ist von Software zu Software unterschiedlich, da z.B. die Konfiguration einer Software immer an die Umgebung angepasst werden muss, in der diese zum Einsatz kommt.\\

Im Falle der o/zb muss der Deployment Prozess die Bereitstellung der o/zb Webanwendung auf einem Server bewerkstelligen. Dies wirft die folgenden Fragen auf: Welcher Webserver wird eingesetzt? Wie gelangt die RoR Webanwendung auf den Server? Und wie arbeiten Anwendungsserver und Webserver auf dem Server zusammen? Diese Fragen werden die nun folgenden Teilabschnitte (kurz) klären.

\subsubsection{Webserver - Apache}
Ein Webserver überträgt Daten an einen Client. Dabei kann dieser die Daten nur lokal oder auch weltweit zur Verfügung stellen. Er dient im Falle der o/zb Webanwendung dazu, die von RoR erzeugten Webseiten an den Clienten auszuliefern. Dies geschieht sobald er die Anfrage eines Clienten aufgenommen und an die RoR Anwendung weitergeleitet hat. Daraufhin verarbeitet die RoR Anwendung diese Anfrage und liefert dem Webserver das Ergebnis zurück. Der Webserver sendet nun diese Daten an den Clienten.\\

Auf dem Testsystem der o/zb (s. \vref{sec:Das_Testsystem}) kommt ein Apache Webserver in der Version 2.2.16 zum Einsatz. Auf dem Testsystem laufen bis zu vier Apache Instanzen gleichzeitig, um die Anfragen der Benutzer bedienen zu können. Weitere Informationen zum Apache Webserver sind unter der Adresse \url{http://www.apache.org} erreichbar.

\subsubsection{Anwendungsserver - Phusion Passenger}
Ein \textit{Anwendungsserver} bietet einer Anwendung die benötigte Laufzeitumgebung, damit diese auch ausgeführt werden kann. Dazu stellt der Anwendungsserver der Anwendung spezielle Dienste zur Verfügung, die die Anwendung zur Ausführung benötigt.\\
Im Fall der o/zb Webanwendung wird der weit verbreitete und leistungsstarke \textit{Phusion Passenger} Anwendungsserver in der Version 3.0.19 genutzt. Phusion Passenger ist ein Modul für den Apache Webserver und ist als ein sogenanntes \textit{RubyGem} (entspricht etwa einem Softwarepaket speziell für Ruby) verfügbar. Zudem ist es auch unter dem Namen \textit{mod\_rails} oder \textit{mod\_rack} bekannt. Weitere Informationen können auf der Webseite von Phusion \url{https://www.phusionpassenger.com/} entnommen werden. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Phusion_Passenger}}

\subsubsection{Capistrano}
Wie Eingangs dieses Abschnittes erwähnt worden ist, sind bei einem Deployment Prozess die Schritte notwendig, die die Bereitstellung der Software bewerkstelligen. Diese Schritte müssen nicht immer manuell ausgeführt werden, sondern können automatisiert werden. Dafür eignet sich im Falle der o/zb Webanwendung die Software \textit{Capistrano}. Diese Software ist ein Open Source Werkzeug, das (Batch-) Skripte auf Servern, z.B. mit der Hilfe einer \textit{Secure Shell (SSH)}, ausführt. Dem zur Folge ist ihr Haupteinsatzzweck in der Softwareverteilung wiederzufinden. Capistrano ist genauso wie die o/zb Webanwendung auch in Ruby geschrieben und als RubyGem verfügbar. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Capistrano_(Software)}}\\

Bei Capistrano bestimmen sogenannte Deployment Rezepte (\glqq Deployment Recipies\grqq) wie der Deployment Prozess verläuft. Auch für die o/zb Webanwendung wurde ein Rezept geschrieben, welches im Abschnitt \vref{subsec:deployment_recipe} beschrieben wird.

\subsection{Versionsverwaltung}
Für einen stabilen und guten Softwareentwicklungsprozess ist eine Versionsverwaltung in der heutigen Zeit unabdingbar. Die Hauptaufgaben bestehen aus der Protokollierung der vorgenommenen Änderungen an Quelltexten, Skripten und anderen Dokumenten. Der Wiederherstellung von alten Zuständen, sodass versehentliche Änderungen oder Änderungen, die z.B. zu Laufzeitfehlern führten, zurückgenommen werden können. Die Archivierung jedes neuen Proejktzustands. Die Koordinierung des gemeinsamen Datei-Zugriffs der am Projekt beteiligten Entwickler. Und zu guter Letzt ermöglicht eine Versionsverwaltung die gleichzeitige Erzeugung mehrerer Entwicklungszweige (sogenannter \glqq Branches\grqq) eines Projektes. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Versionsverwaltung}}

\subsubsection{Git}
% Wie sieht aktuelle Setup aus?
Für das Projekt der o/zb Stuttgart wird die weit verbreitete, freie Software \textit{Git} verwendet. Es wurde ursprünglich für die Quelltext-Verwaltung des Linux Kernels entwickelt.\\
Git ist im Gegensatz zu den Traditionellen Versionsverwaltungen wie z.B. \textit{SVN} oder \textit{Mercurial} ein verteiltes Versionsverwaltungssystem. Es gibt keinen zentralen Server auf dem das Projekt gespeichert wird, sodass jeder Entwickler eine lokale Kopie des gesamten Repositorys vorliegen hat - \textit{clone}. Dem zur Folge hat der Entwickler die Möglichkeit auch ohne Netzwerkzugriff die einzelnen Zustände seiner Arbeit festzuhalten - \textit{commit}. Besteht wieder ein Netzwerkzugriff kann er seine Änderungen auf das von den Entwicklern gemeinsam genutztes Projekt-Depot (\textit{Repository}) hochladen - \textit{push}. Zuvor muss er sich jedoch mit dem gemeinsamen Repository synchronisieren - \textit{pull}. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Git}}\\

Das aktuelle, gemeinsame Repository des o/zb Projektes wird von dem bekannten Git-Hoster \textit{GitHub} bereitgestellt. Die Adresse zum Repository lautet: \url{https://github.com/Avenel/FirstApp}.

\subsection{Workflow, Umsetzung}
% Workflow: Git add/commit/push, cap deploy
In diesem Teilabschnitt werden die vorher erläuterten Konzepte \textit{Deployment} und \textit{Versionsverwaltung} in Zusammenhang gebracht. Es wird ein Arbeitsablauf (\glqq Workflow\grqq) defininert, der den Deployment Prozess beschreibt. Dieser Arbeitsablauf wird in Abbildung \vref{fig:deployment_workflow} dargestellt.

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.90\textwidth]{\string"Media/Deployment Workflow\string".pdf}
     \end{center}
     \caption{Der Deployment Workflow}
     \label{fig:deployment_workflow}
\end{figure} 

Möchte der Entwickler seine Arbeit auf dem Server bereitstellen, ist er angehalten sich den aktuellen Projektstatus aus dem gemeinsamen Repository zu holen. Er ist dafür verantwortlich sein Projekt vor jedem Commit auf den neuesten Stand zu bringen. Dies geschieht mit der Anweisung \textit{git pull}. Kommt es zu (Datei-) Konflikten die Git nicht automatisch selber lösen kann, muss der Entwickler selber eingreifen (\textit{merge}). Er wiederholt diesen Vorgang solange, bis sein Projekt konfliktfrei und auf dem neuesten Stand ist. Erst dann kann er ausgewählte Änderungen am Projekt für einen neuen \textit{Commit} hinzufügen (\textit{git add}). Im Anschluss schließt er den Commit-Prozess mit dem Befehl \textit{git commit -am "Kommentar"} ab. Damit auch das gemeinsame Repository auf den aktuellsten Stand gebracht wird, erfolgt der Befehl \textit{git push}. Dieser lädt die neuesten Änderungen hoch.\\

Wurde das gemeinsame Repository nun auf den neuesten Stand gebracht, kann der letzte Schritt im Deployment Workflow durchgeführt werden. Mit \textit{cap deploy} wird das, im nächsten Abschnitt beschriebene, Deploymentskript ausgeführt. 

\subsubsection{Das Capistrano Deploymentskript (Rezept)}\label{subsec:deployment_recipe}
Das Capistrano Deploymentskript bzw. Rezept ist vorerst nicht im öffentlich zugänglichen Git Repository zu finden, da es durchaus sensible Informationen enthält. Ist es vorhanden befindet es sich hier: \textit{config/deploy.rb}.\\
In dem Deploymentskript werden zuerst sämtliche Variablen festgelegt, der Name der Anwendung und die für einen sicheren SSH Zugriff notwendigen Daten (Serveradresse, sowie auch der Deployment-Benutzer: \glqq ozbapp\grqq). Darüber hinaus werden Informationen zum Repository angegeben, in dem die Projektdateien liegen. Im Anschluss wird der Deployment Ort auf dem Server, sowie eigene Aktionen während des Deployment Vorgangs festgelegt.

\begin{lstlisting}[frame=single, caption=Capistrano Deployment Rezept, tabsize=2, flexiblecolumns=true, captionpos=b]{Deploy.rb}
# Name application
set :application, "ozbapp"

# Setup deployment user and server ip
server "188.64.45.50", :web, :app, :db, :primary => true
set :user, "ozbapp"
set :use_sudo, false
ssh_options[:forward_agent] = true

# Setup git repository information
set :scm, "git"
set :repository, "https://github.com/Avenel/FirstApp.git"
set :branch, "master"

# Setup where to deploy the app on the server
set :deploy_to, "/home/#{user}/apps/#{application}"
set :deploy_via, :remote_cache

namespace :deploy do

     desc "Tell Passenger to restart the app."
     task :restart do
          run touch "#{current_path}/ozbapp/tmp/restart.txt"
     end

     desc "Renew SymLink"
     task :renew_symlink do
          run "rm /home/ozbapp/ozbapp"
          run "ln -s /home/ozbapp/apps/ozbapp/current/ozbapp /home/ozbapp/ozbapp"
     end

end

# Execute renew_symlink after update_code
after 'deploy:update_code', 'deploy:renew_symlink'
\end{lstlisting}

\clearpage
\section{Datenbank Migration}
% Welche Skript gibt es und was tun diese?
% Wie wird das auf dem Server ausgeführt?
In der vergangenen Zeit wurde ein Java Datenbank Migrationstool geschrieben, welches die Daten von dem aktuellen Produktivsystem in das neue System übertragen soll. Um den Umgang mit diesem Tool zu erleichtern sind zwei Batch Skripte angefertigt worden. Diese Batch Skript sind im Ordner \textit{tools} des Git Repositorys und auch auf dem Server im \textit{Home Verzeichnis ozbapp} zu finden. Um die Batch Skripte ausführen zu können ist eine SSH Verbindung erforderlich. Diese kann unter Windows mit dem Programm \textit{Putty} (\url{http://www.putty.org/}) oder unter Linux mit dem Befehl \textit{ssh username@host} (\url{http://wiki.ubuntuusers.de/SSH}) geöffnet werden. Der Username bzw. der Hostname ist in beiden Fällen \textit{ozbapp} bzw. \textit{ozbapp.mooo.com}. Die benötigte Konfiguration für Putty ist der Abbildung \vref{fig:putty_config} zu entnehmen. Ist man verbunden befindet man sich automatisch schon im \textit{Home Verzeichnis} in dem die Batch Skripte vorliegen.\\ 

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.60\textwidth]{\string"Media/putty_configuration\string".png}
     \end{center}
     \caption{Putty Konfiguration}
     \label{fig:putty_config}
\end{figure} 

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.60\textwidth]{\string"Media/putty_open_session\string".png}
     \end{center}
     \caption{Offene SSH Session in Putty}
     \label{fig:putty_open_session}
\end{figure} 

Im Folgenden werden die Funktionsweise und die Benutzung dieser beiden Batch Skripte beschrieben. 

\subsection{Datenbank migrieren}
Dieses Batch Skript importiert zunächst einen aktuellen Stand der Produktivdatenbank, der als MySql Dump zur Verfügung gestellt wird, in die auf dem Testserver liegende Produktivdatenbank \textit{ozb\_prod}. Im Anschluss wird die Testserver Testdatenbank \textit{ozb\_test} geleert und neu angelegt. Ist dies geschehen, werden mit Hilfe des Datenbank Migrationstools die Daten aus der Produktivdatenbank \textit{ozb\_prod} in die Testdatenbank \textit{ozb\_test} übertragen. Das neue Datenbankschema wird in der Datei \textit{create\_tables.txt} beschrieben. Sind Veränderungen am Datenbankschema vorgenommen worden, müssen diese in dieser Datei übernommen werden. Ausgeführt wird dieses Skript mit dem Befehl \textit{./datenbank\_migrieren.sh}.\\

\lstinputlisting[language=bash, frame=single, caption=datenbank\_migrieren.sh, tabsize=2, flexiblecolumns=true, captionpos=b]{\string"../tools/datenbank_migrieren\string".sh}

\subsection{Datenbank zurücksetzen}
In diesem Batch Skript wird die Testdatenbank auf den ursprünglichen Zustand zurückgesetzt. Der ursprüngliche Zustand liegt in dem MySql Dump \textit{dump.sql}. Zur Ausführung genügt auch hier der folgende Befehl \textit{./datenbank\_ruecksetzen.sh}. \\

\lstinputlisting[language=bash, frame=single, caption=datenbank\_migrieren.sh, tabsize=2, flexiblecolumns=true, captionpos=b]{\string"../tools/datenbank_ruecksetzen\string".sh}

\clearpage
\chapter{Korrekturen, Bugfixes}
% WebImport
\section{Webimport}
In der o/zb Webanwendung sorgt der sogenannte \textit{Webimport} für die Übertragung der in einer CSV Datei hinterlegten Kontobewegungen. Weitere Informationen zu dem Webimport kann der Projekt Dokuementation WS 12/13 (ab S.53) entnommen werden.\\

Zum Zeitpunkt der Aufnahme der Arbeiten an diesem Projekt funktionierte der Webimport nicht korrekt. Die folgenden Punkte sind aufgefallen:

\begin{itemize}
     \item{Datei Upload auf dem Testsystem funktioniert nicht.}
     \item{Laufzeitfehler müssen abgefangen werden.}
     \item{Die Anzahl der importierten Datensätze stimmt nicht.} 
\end{itemize}

\subsection{Bugfix: Datei Upload}
Bei diesem Fehler akzeptierte der Webimport scheinbar keine Datei. Der Grund hierfür liegt in den abgebildeten Zeilen in Listing \vref{listing:webimport_nil}.\\

\lstinputlisting[language=Ruby, frame=single, caption=webimport\_controller.rb, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=423, lastline=427]{\string"../ozbapp/app/controllers/webimport_controller\string".rb}\label{listing:webimport_nil}

In Zeile 4 (bzw. Zeile 426) wurde ursprünglich der Befehl \textit{uniq!} verwendet. Methoden mit einem Ausrufezeichen (!) benutzen meistens eine unsichere Implementierungsweise der Methode. Dieser Befehl gibt laut der offiziellen RubyDoc \footnote{vgl. \url{http://www.ruby-doc.org/core-1.9.3/Array.html\#method-i-uniq-21}} entweder ein \textit{Array} oder \textit{nil} zurück. Der Rückgabewert \textit{nil} tritt ein, sobald das Array keine Elemente vorweisen kann. Da dieser Fall nicht abgefangen worden ist, kommt es in der Zeile 4 (bzw. 426) zu einem Fehler. Abhilfe schafft hier die Methode \textit{uniq}. Diese gibt in jedem Fall ein (ggf. leeres) \textit{Array} zurück. 
\subsection{Laufzeitfehler}
Konnte ein Datensatz z.B. aufgrund eines MySql Fehlers nicht importiert werden, wird eine Exception geworfen. Aufgrund dieser Exception wurde der Importvorgang nicht korrekt zu Ende geführt, sondern direkt abgebrochen. Der Benutzer sieht in diesem Moment eine Fehlerseite und kann nicht mehr agieren, da er keine Informationen darüber erhält, was schiefgegangen ist. Der häufigste Fehler tritt auf, wenn versucht worden ist eine Buchung noch ein weiteres Mal zu importieren (MySql Fehler: \textit{duplicate key error}). Nun gilt es mit Hilfe des Exception Handlings das Verhalten der Webanwendung zugunsten des Benutzers zu beeinflussen.\\

Die Exceptions treten beim Speichervorgang auf, dem zur Folge wurde um jeden Speichervorgang ein \textit{begin-rescue} Block gesetzt. Dieser fängt die Exception auf und hängt die Fehlermeldung der \textit{@error} Variable an. Diese stellt dem Benutzer ggf. die Informationen darüber, was schiefgelaufen ist, dar.\\

\lstinputlisting[language=Ruby, frame=single, caption=webimport\_controller.rb, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=278, lastline=285]{\string"../ozbapp/app/controllers/webimport_controller\string".rb}\label{listing:webimport_nil}


\subsection{Anzahl der importierten Datensätze}
Eine weitere Auffälligkeit bestand in der angezeigten Anzahl der importierten Datensätze. Diese Zahl zeigte ggf. zu viele importierten Datensätze an. Unter einem Datensatz versteht man eine Kontobewegung in der CSV Datei.\\

Einer der Fehler tritt in Zeile 318 auf. Dort werden bei einer bestimmten Kontobewegung zwei Buchungen durchgeführt. Beide Buchungen wurden mitgezählt, obwohl der Auslöser nur \textit{ein} Datensatz gewesen ist. Durch Auskommentieren und einem Hinweiß konnte dieser Fehler korrigiert werden.\\

\lstinputlisting[language=Ruby, frame=single, caption=webimport\_controller.rb, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=313, lastline=321]{\string"../ozbapp/app/controllers/webimport_controller\string".rb}\label{listing:webimport_nil}


\subsection{Punkteberechnung}
Beim Import der Buchungen werden zum Zeitpunkt der Übernahme noch keine Punkte berechnet. Im Zuge der Modul Tests wurden die mit dem Webimport verbundenen Module nochmals überarbeitet. Auf Grund des immensen Arbeitsaufwands, der in das Refactoring gesteckt werden musste, wurde eine erneute Implementierung der Punkteberechnung im Rahmen dieser Projektarbeit nicht in Betracht gezogen. 

% Darlehensverlauf
\section{Darlehensverlauf}
Der Darlehensverlauf ist zum Zeitpunkt der Übernahme fehlerhaft gewesen. Im Zuge in den von Herrn Kienle angefertigten Tests, konnten die auftretenen Fehler analysiert und kategorisiert werden. Aufgrund des relativ unstrukturierten und unübersichtlichen Programmcodes, wurde beschlossen diese Funktionalität, basierend den Spezifikationen die sich aus den Tests und Dokumentationen ableiten ließen, neu zu implementieren.\\

\textbf{Fehlerursachen:}

\begin{itemize}
     \item{Punkte wurden nicht richtig berechnet, wenn am Tage des abDatums noch Buchungen getätigt wurden}
     \item{Die Sortierung der Buchungen stimmte nicht mit den Vorgaben überein}
     \item{Wiederverwendete ZE Konten wurden nicht richtig berücksichtigt}
     \item{Startsaldo wurde nicht korrekt berechnet, da die Tagesdifferenz zur letzten Währungsbuchung nicht berücksichtigt wurden}
     \item{Die Punkte die bei der Buchung nach dem Startsaldo berechnet wurden, sind falsch da diese einfach aus der DB entnommen wurden}
     \item{Variable KKL-Verläufe, KKL veränderte sich während des abgefragten Zeitraumes}
\end{itemize} 

% Lösung
Diese Ursachen wurden bei der kompletten Neu-Implementierung beachtet und umgesetzt. Integrationstest, beschrieben in Kapitel \ref{} sichern die korrekte Funktionalität in den gegebenen Awendungsfällen.

\section{HistoricRecord}
Im Zuge des Test-Driven Development und dem damit verbundenen Refactoring, ist aufgefallen das für jedes historisierte Model im Grunde derselbe Quellcode geschrieben wurde, der für die Historisierung zuständig gewesen ist. Dieser lässt sich nur sehr schlecht warten und im allgemeinen ist großer, redundanter Quellcode, wie hier vorgefunden wurde, schlecht. Daher wurde ein neues Ruby-Modul implementiert: \textit{HistoricRecord}. Dieses Ruby-Modul lässt sich für jedes Model anwenden, wenn dies die folgenden Methoden implementiert und Kriterien beachtet.\\

\textbf{get\_primary\_keys}\\
Diese Methode liefert den primären Schlüssel, bis auf das Attribut GueltigVon (dies ist in jedem primären Schlüssel einer historisierten Klasse enthalten). Abbildung \vref{listing:getPrimaryKeys} zeigt eine beispielhafte Implementierung.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=11, lastline=13]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:getPrimaryKeys}

\textbf{set\_primary\_keys}\\
Die Methode \textit{set\_primary\_keys(values)} erwartet die Werte für den primären (zusammengesetzten) Schlüssel. Nach Aufruf entsprichen die Werte der primärschlüssel Attribute den angegebenen Werten. Abbildung \vref{listing:setPrimaryKeys} zeigt eine beispielhafte Implementierung.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=15, lastline=17]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:setPrimaryKeys}

\textbf{getLatest}\\
Die Methode \textit{getLatest} liefert die aktuellste Version der Model Instanz zurück, bevor die Änderungen abgespeichert werden. Sie ist notwendig, um die GueltigBis Zeit für diese Instanz neu zu setzen. Abbildung \vref{listing:getLatest} zeigt eine beispielhafte Implementierung.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=132, lastline=134]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:getLatest}

\textbf{Attribute: GueltigVon, GueltigBis}\\
Diese Attribute müssen auf jeden Fall vorhanden sein, sowohl als \textit{accessible attribute} als auch in der Datenbank. \\

Sind diese Voraussetzungen erfüllt, muss das Modul noch eingebunden werden. Da Ruby keinen \textit{Polymorphismus} (Mehrfachvererbung) unterstüzt, wird \textit{Duck typing} (s. \url{http://en.wikipedia.org/wiki/Duck_typing}) angewandt. Abbildung \vref{listing:duckTyping} zeigt, wie es geht.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=2, lastline=5]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:duckTyping}


\section{Umzug der Benutzerattribute in die Tabelle User}
% TODO
[TODO]

\clearpage
\chapter{Testdriven Development}
In diesem Kapitel wird die Einführung und Durchführung der Eigenschaften der Testgetriebenen Entwicklung beschrieben. Im Zuge dessen wird zunächst eine Analyse des Ist und des Soll Standes durchgeführt, bevor mit der Umsetzung und Durchführung fortgefahren wird. Das Ziel ist die Einführung und Durchführung von Tests, um den Zustand der Webanwendung darzulegen und um die aufgezeigten Mängel zu beseitigen und mit Hilfe der Tests nicht wieder eintreten zu lassen.    

\section{Analyse}
% Ist-Analyse: Es gibt keine Tests, Fehlerbehaftete Anwendung
\subsection{Ist-Stand}
Der Ist-Zustand der vorliegenden Webanwendung ist zum Zeitpunkt der Übernahme nur schwer überschaubar. Es gibt viele neue Funktionalitäten und Testberichte die deutliche Mängel aufzeigen. Die vorliegenden Dokumentationen beschreiben die neuen Funktionalitäten und deren Umsetzung, allerdings fehlt ein Überblick über den Gesamtzustand der Webanwendung. Es wurden nur einzelne, wichtige, Funktionalitäten getestet. Allerdings handelt es sich hierbei um Frontend Tests, die jedoch keine ausreichenden Aussagen über die fachliche und technische Korrektheit der Module und deren Beziehungen untereinander liefern können.\\

Um gültige Aussagen über den Zustand dieser Webanwendung treffen zu können, sind umfangreiche Modultests der erste Schritt. Diese liefern den Zustand über die einzelnen Module, bzw. Entitäten wie z.B. Person, OZBPerson, OZBKonto usw. zurück. Auch liefern diese Aussagen über die Korrektheit der Umsetzung des vorgegeben Datenmodells. Hier sind auf dem ersten Blick bereits einige Unstimmigkeiten aufgefallen.\\

% Soll-Analyse: bugfrei durch TDD. Was müssen wir dafür testen?
\subsection{Soll-Stand} 
Ein erster Meilenstein stellt die korrekte Umsetzung des fachlichen Datenmodells dar. Dazu gehört, dass jedes Model den fachlichen Beschreibungen entspricht und sauber implementiert wurde. Im Idealfall ist die Struktur aller Module gleich, der Code auf ein Minimum reduziert und konsistent hinsichtlich z.B. der Attributsnamen und der Art und Weise wie bestimmte Funktionalitäten (wie z.B. die Suche nach einer Modulinstanz) implementiert wurden. Die Modul Tests gewährleisten hierbei die fachlich korrekte Umsetzung. Auf die technisch konsistente Umsetzung der Module muss der Entwickler selbst achten.\\
Der nächste Meilenstein stellt eine einheitliche, technisch und fachlich korrekte Implementierung der Controller und den dazugehörigen Views dar. Hierbei stellt die korrekte Umsetzung der Module das Standbein und somit auch die notwendige Weiche für diesen Meilenstein. Hierbei gewähren die Controller Tests eine fachlich korrekte Umsetzung, ehe sich die Feature Tests auch von der korrekten Umsetzung in einem konkreten Anwendungsfall, der mehrere Controller involviert, überzeugen kann.

\section{Implementierung}
In diesem Abschnitt wird die Umsetzung der Tests beschrieben. Dazu gehört eine kurze Zusammenfassung aller benutzten Gems und wie sie eingesetzt wurden. Im Anschluss werden nacheinander Modul und Controller Tests vorgestellt. Dabei werden Aufbau und Funktionsweise anhand von Beispielen erläutert. Darüber hinaus gibt es eine Auflistung in der alle getesteten Modulen verzeichnet sind.
\subsection{Verwendete Gems}
\subsubsection{RSpec}
\textit{RSpec} (s. \url{http://rubygems.org/gems/rspec}) ist das wohl bekannteste Testing-Framework für Ruby on Rails Applikationen. Es ist im Sinne des \textit{Behaviour-Driven Development} entstanden und soll das Test-Driven Development unterstützen und leichter zugänglich machen. Das Verzeichnis \textit{/spec} birgt alle Dateien, die mit dem Testing in Verbindung stehen.

\subsubsection{FactoryGirl}
\textit{Factory\_girl} (s. \url{http://rubygems.org/gems/factory_girl}) stellt ein alternatives Framework zu den Ruby Fixtures zur Verfügung, das es erlaubt Daten mit Hilfe einer \glqq Factory\grqq (=Fabrik, s. \url{http://de.wikipedia.org/wiki/Abstract_Factory}) zu generieren. In diesr Webapplikation lassen sich somit Beispieldaten für die Tests leichter erzeugen. Abbildung \vref{listing:default_factory} zeigt einen Ausschnitt einer typischen Factory.  

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=3, lastline=12]{\string"../ozbapp/spec/factories/adressen\string".rb}\label{listing:default_factory}

\subsubsection{Faker}
\textit{Faker} (s. \url{https://rubygems.org/gems/faker}) ist ein Tool für die Erzeugung von Fake Adressen, Namen, Telefonnummern und mehr. Dieses Gem ergänzt sich prima mit den oben genannten Factories. Eine detaillierte Beschreibung aller Möglichkeiten können unter der folgenden URL entnommen werden: \url{http://rubydoc.info/github/stympy/faker/master/frames}.

\subsection{Gems die zukünftig verwendet werden könnten}
In diesem Abschnitt werden Gems genannt, die in Zukunft den Test-Driven Development unterstützen könnten.
\subsubsection{Capybara}
\textit{Capybara} (s. \url{http://rubygems.org/gems/capybara}) hilft, die Benutzerinteraktionen mit der Web-Applikation zu simulieren. Somit lassen sich Integrations Tests implementieren, die noch enger mit der Weboberfläche verzahnt sind.

\subsubsection{Guard-Spec}
\textit{Guard-spec} (s. \url{http://rubygems.org/gems/guard-rspec}) dient dem Entwickler dazu, Tests automatisch (z.B. nach jedem Speichervorgang) auszuführen. 

\subsection{Entwicklertools}
In die Auswahl der Entwicklertools wurde viel Zeit investiert, die im Nachhinein durch gute Auswahl wieder eingespart wurde. Um den nachfolgenden Studenten diesen Aufwand zu ersparen, werden in diesem Abschnitt die verwendeten Entwicklertools kurz aufgelistet und erläutert. 

\subsubsection{Sublime Text 2}
\textit{Sublime Text 2} (s. \url{http://www.sublimetext.com/}) hat sich als ein sehr guter Texteditor (ähnlich VI und Textmate) herausgestellt. Er ist einfach zu bedienen, kann aber genauso viel wie seine Vorbilder. Durch Plugins kann der Funktionsumfang laufend erweitert werden. Diese fügen sich weniger aufdringlich in die Benutzeroberfläche ein (wie z.B. bei Notepad++). Weitere Links zu hilfreichen Webseiten können dem Wiki des Repositories entnommen werden (s. \url{https://github.com/Avenel/FirstApp/wiki/Sublime-Text-Setup}).
Welche Plugins für das Test-Driven Development verwendet wurden, kann dem nun folgenden Abschnitt entnommen werden. 

\subsubsection{RubyTest}
\textit{RubyTest} (s. \url{https://github.com/mhartl/rails_tutorial_sublime_text}) ist ein Sublime Text 2 Plugin, dass den Entwickler bei der Ausführung der Tests hilft. Wie die Installation von statten geht und wie das Plugin benutzt wird, kann diesem Youtube Video entnommen werden \url{http://www.youtube.com/watch?v=05x1Jk4rT1A}. Man hat die Möglichkeit entweder alle Tests eines geöffneten Dokuments mit der Tastenkombination \textit{STRG+SHIFT+T}, oder nur einen einzelnen Test (in dem sich der Cursor befindet) mit der Tastenkombination \textit{STRG+SHIFT+R} auszuführen.


\subsubsection{Cygwin}
Falls man unter Windows entwickelt ist \textit{Cygwin} eine sehr gute Alternative zu der herkömmlichen Windows Kommandozeile. Die Standardinstallation von Cygwin, zu finden hier: \url{http://www.cygwin.com/}, reicht in der Regel aus. Der große Vorteil hier ist, dass das Fenster frei skalierbar ist und sich der Text (z.B. die Ausgabe des Serverlogs) leichter lesen und markieren lässt. 

\subsection{Modul Tests}
Ein Modul Test besteht aus drei Teilen:
\begin{itemize}
     \item{Testing der Factory}
     \item{Testing der Attribut-Validierungen}
     \item{Testing der Klassen/Instanz Methoden}
\end{itemize}

\subsubsection{Factory Test}
Wie bereits in einem früheren Abschnitt gezeigt, werden Factories verwendet um Testdaten zu generieren. Damit sichergestellt ist, dass diese auch korrekt funktionieren besteht der erste Test darin, genau dies sicherzustellen. Abbildung \vref{listing:default_test_factory} stellt beispielsweise einen solchen Test dar.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=6, lastline=9]{\string"../ozbapp/spec/models/bank_spec\string".rb}\label{listing:default_test_factory}

\subsubsection{Attribut-Validierungen}
Attribute müssen in den meisten Fällen bestimmten Kriterien entsprechen. Sie dürfen mal nur eine Nummer sein, mal einem bestimmten regulären Ausdruck entsrechen, müssen vorhanden sein oder auch nicht. Wichtig ist, dass man die folgenden Fälle, die Abbildung \vref{listing:default_test_attributes} zeigt abdeckt.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=29, lastline=45]{\string"../ozbapp/spec/models/bank_spec\string".rb}\label{listing:default_test_attributes}

\subsubsection{Klassen/Instanz Methoden}
Jede Klasse besitzt eigene (private) Methoden die auch getestet werden müssen. Das Prozedere ist auch hier dasselbe, man gibt eine Instanz des zu testenden Models vor, führt die Methode aus und erwartet ein Ergebnis.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=82, lastline=87]{\string"../ozbapp/spec/models/person_spec\string".rb}\label{listing:default_test_instance_methods}

Falls die Methode eine private Methode ist, muss die Methode auf den folgenden Wege aufgerufen werden, wie es Abbildung \vref{listing:execute_private_methode} zeigt.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=337, lastline=338]{\string"../ozbapp/spec/models/ozb_konto_spec\string".rb}\label{listing:execute_private_methode}

\subsubsection{HistoricRecord}
Auch dieses Modul wurde gesondert getestet. Abbildung \vref{listing:historicRecordTestExample} zeigt stellvertretend die Art und Weise, wie jede einzelne Methode getestet wurde. Dabei ist es wichtig, dass zuerst jede einzelne Funktion für sich isoliert getestet wurde, bevor jedes einzelne Model nochmals eigenständig auf die korrekte Funktionsweise hin geprüft wurde.

 \lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=461, lastline=510]{\string"../ozbapp/spec/models/HistoricRecord_spec\string".rb}\label{listing:historicRecordTestExample}


\subsubsection{Gesteste Models}
Die folgenden Models wurden getestet.

\begin{itemize}
     \item{Bank}
     \item{Bankverbindung}
     \item{Buergschaft (Skelett)}
     \item{EEKonto}
     \item{OZBKonto}
     \item{OZBPerson}
     \item{Person}
     \item{Projektgruppe}
     \item{User}
     \item{Waehrung}
     \item{ZEKonto}
\end{itemize}

\subsection{Controller Tests}


\subsubsection{Anwendungsfälle der einzelnen Tests}

% Auswertung der bisherigen manuellen Tests
\section{Auswertung}
Die Auswertung befindet sich im Anhang Kapitel \vref{sec:appendix}.

\chapter{Neue Features}
\section{PaperTrail - Historisierung}

\clearpage

\section{Deployment E-Mail Benachrichtigung}
s. Capify Skript: \glqq cap\_notify.rb\grqq

\chapter{Ergebnis und Ausblick}
\section{Ergebnis}
\section{Ausblick}

\clearpage
\appendix
\chapter{Anhang}\label{sec:appendix}
\section{Test-Driven-Development Präsentation}
\includepdf[pages={1-25}]{TDDPresentation.pdf}
\clearpage
\section{Definition der o/ZB Attribute}
\label{chapter:ozb_attribute}
\includepdf[pages=-, landscape=true]{Media/definition_ozb_attribute.pdf}

\newpage
%\addcontentsline{toc}{chapter}{Abbildungsverzeichnis}
\listoffigures

\newpage
%\addcontentsline{toc}{chapter}{Tabellenverzeichnis}
\listoftables

\newpage
%\addcontentsline{toc}{chapter}{Listingsverzeichnis}
\lstlistoflistings

\newpage
%\addcontentsline{toc}{chapter}{Literatur}
\bibliography{sources}

\end{document}

