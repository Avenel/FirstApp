\documentclass[12pt,             % Schriftgroesse
               a4paper,          % Papierformat
               %liststotoc,      % (alt) Tabellen- und Abbildungsverzeichnis im Inhaltsverz.
               listof=totoc,     % Tabellen- und Abbildungsverzeichnis im Inhaltsverz.
               %idxtotoc,        % (alt) Index im Inhaltsverz. auffuehren
               index=totoc,      % Index im Inhaltsverz. auffuehren
               %bibtotoc,        % (alt) Literaturverzeichnis im Inhaltsverz. auffuehren
               bibliography=totoc,% Literaturverzeichnis im Inhaltsverz. auffuehren
               oneside,         % auskommentieren, wenn beidseitig gedruckt wird
                                 % default ist 'twoside'
               BCOR1cm,          % zusaetzlicher Bindungsrand
               english   %  Englisch als weitere Sprache, Deutsch als Hauptsprache
               ]{scrbook}

\usepackage[utf8]{inputenc}  
\usepackage[T1]{fontenc}
\usepackage{lmodern}         
%\usepackage{eurosym}  
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage[left=20mm, right=20mm, top=25mm]{geometry}
\usepackage{listings} \lstset{numbers=left, numberstyle=\tiny, numbersep=5pt, basicstyle =\footnotesize\ttfamily, showspaces=false, showstringspaces=false} 
\lstset{language=ruby}
\usepackage{url}
\setlength\parindent{0pt} 
\usepackage{float}

\usepackage{hyperref}
\linespread{1.3}
\usepackage{multicol}
\usepackage[german]{varioref}

\usepackage{pdfpages}

\bibliographystyle{alphadin}

\setcounter{tocdepth}{1}

\usepackage[]{acronym}


\lstset{
    frame=single,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\title{Testdriven Development am Beispiel der o/ZB Webapplikation}
\author{Martin Briewig, Michael Leibel}


\begin{document}

\pagestyle{empty}
\begin{center}

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.70\textwidth]{\string"Media/hskalogo\string".jpg}
	\end{center}
	\label{fig:hska_logo}
\end{figure} 

\vspace{5\baselineskip}

\textsc{\Huge Test-Driven Development\\ mit Ruby on Rails}\\[0.25cm]
\textsc{\large am Beispiel der o/ZB Webapplikation}\\[1.5cm]


\vspace{2\baselineskip}

\textsc{\LARGE Projektarbeit}\\[1.5cm]


\vspace{5\baselineskip}

vorgelegt von\\
Briewig, Martin, B.Sc. (Matr.-Nr.: 43509)\\
Leibel, Michael, B.Sc. (Matr.-Nr.: 43674)

\vspace{\baselineskip}

Betreuer: Prof. Dr. Frank Schaefer

Fachbereich: Informatik (Master)
\end{center}

\clearpage{}

\pagenumbering{roman} 

\tableofcontents{}

\clearpage{}

%\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
\chapter*{Abkürzungsverzeichnis}

\begin{acronym}[SQL]
	\acro{AP}{Arbeitspaket}
	\acro{o/ZB}{Ohne Zins Bewegung}
     \acro{RoR}{Ruby on Rails}
     \acro{SSH}{Secure Shell}
\end{acronym}

\newpage

\pagenumbering{arabic} 
\chapter{Einleitung}
Die ohne Zins Bewegung Stuttgart arbeitet nun seit einigen Jahren mit der Hochschule Karlsruhe zusammen an einer Webanwendung. Diese Webanwendung soll die Geschäftsprozesse der Bewegung unterstützen und verwalten. Im Laufe der letzten Jahre ist aus der ursprünglichen Idee eine komplexe Webanwendung entstanden, die nun gründlich auf Fehler überprüft und gegebenenfalls ausgebessert werden soll. 
Diese Aufgabe wird nun uns, Herr Briewig und Herr Leibel, anvertraut. Im Folgenden wird eine detaillierte Aufgabenstellung formuliert, an dieser sich diese Projektarbeit messen lassen wird.  

\section{Aufgabenbeschreibung}
Die Aufgaben dieser Projektarbeit sind recht vielfältig. Sie lassen sich in 4 Phasen einteilen. Die Aufgaben pro Phase wurden maßgeblich von den Meetings geprägt.

\subsection{Phase 1: Korrekturen, Dokumentieren}
\textbf {(Duedate: 02.05.2013)}\\
% Korrekturen am ER Diagramm/Relationenmodell
%    -    ER Diagramm soll der Implementierung entsprichen
%    -    Darstellung aller PKs und FKs für den nicht historisierten Fall
Die erste Phase wird von den Korrekturen am ER-Diagramm und dem dazugehörigen Relationsmodell dominiert. Das ER-Diagramm weißt noch ein paar Unstimmigkeiten auf, die im Laufe der Zeit entstanden sind. Diese gilt es zu bereinigen und die vorgenommenen Korrekturen in der Implementierung umzusetzen. Ziel ist ein ER-Diagramm, dessen Entitäts-Beziehungen den nicht-historisierten Zustand darstellen. Dieses ER-Diagramm soll 1:1 in der Implementierung vorzufinden zu sein. Es soll vereinfacht dargestellt werden, lediglich die Primär- und Fremdschlüssel, die im historisierten Zustand gültig sind, sollen den Entitäten als Zusatzinformationen dienen.\\

% Dokumentieren:
%    -    DB-Migration, wie geht das?
%    -    Deployment, wie funktioniert das?
Neben den Korrekturen am ER-Diagramm sind Dokumentationen der Vorgehens- und Funktionsweise des Datenbank Migrationstools notwendig. Hierfür sind zwei Batch-Skripte angefertigt worden, deren Nutzungs- und Funktionsweisen zu dokumentieren sind.\\

Im Laufe der Zeit sind die verschiedensten Techniken zur Bereitstellung und Versionierung der o/ZB Webanwendung verwendet worden. Es gilt nun, einen einheitlichen Vorgang zu definieren der für die nachfolgenden Projektgruppen verwendet werden soll. Basierend auf der anzufertigten Dokumentation, kann die Bereitstellung und Versionierung stetig verbessert werden.\\

% Allgemeine Korrekturen:
%    -    WebImport
Zusätzlich soll in dieser Phase ein kritischer Fehler bereinigt werden. Der WebImport, welcher für den Import der Kontobewegungen verantwortlich ist, arbeitet nicht richtig. Zur Zeit ist der Datei-Upload auf dem Testsystem nicht möglich. Darüber hinaus kommt es bei einer lokalen Testumgebung zu Laufzeitfehlern. Auch die im Webfrontend angezeigte Anzahl der importierten Datensätze ist nicht korrekt.

\subsection{Phase 2: Korrektur der Darlehensverlaufsanzeige}
\textbf {(Duedate: 23.05.2013)}\\
% Allgemeine Korrekturen:
%    -    Korrektur der Punkteberechnung
In der zweiten Phase soll das Hauptaugenmerk auf die Korrektur der Darlehensverlaufsanzeige gelegt werden. Diese Anzeige gilt als einer der Kerngeschäftsprozesse. Hier wird der Buchungsverlauf über einen, vom Benutzer festgelegten, Zeitraum dargestellt. Dabei ist es wichtig, die korrekten Punkte- und Währungs-Saldi zu berechnen. Dies funktioniert in der aktuellen Version nicht korrekt. Daher gilt es, die Fehler auszumerzen.  


\subsection{Phase 3: Einrichtung Testdriven Development, Erstellung der Model Tests}
\textbf {(Duedate: 13.06.2013)}
% Tests
%    -    Beschreibung der Testumgebung mit Sublime 2(?) und RSpec
%    -    Testfälle entwickeln
% Feature:
%    -    Dokumente (Word,PDF) generieren

Dies Phase steht im Zeichen der Einführung der Testgetriebenen Entwicklung (\glqq Testdriven Development\grqq). In der Vergangenheit ist die Webanwendung stark gewachsenen, es sind immer häufiger Fehler und Inkonsistenzen aufegfallen. Ziel ist es nun der Anwendung, mit Hilfe von Tests, zu einem konsistenten und möglichst fehlerlosen Zustand zu verhelfen. Auch sollen die Tests helfen, sich einen genaueren Überblick über den Zustand der Webanwendung zu verschaffen. Für eine erfolgreiche und effiziente Test-Entwicklung, ist eine gute Auswahl der Tools unabdingbar. Der Gebrauch dieser Tools soll auch festgehalten werden.

\subsection{Phase 4: Datenmodellkorrekturen, Implementierung Integrationtests}
\textbf {(Duedate: 11.09.2013)}
Nachdem sich ein detaillierter Überblick über den Zustand der Webanwendung verschafft worden ist, wird das Datenmodell festgelegt, implementiert und erneut getestet. Ist dies abgeschlossen, werden beispielhafte Integrationstest implementiert und dokumentiert. Diese dienen dann den Nachfolgern als Anhaltspunkt für den weiteren Werdegang dieser Webanwendung. Außerdem werden grobe Fehler in der Webanwendung behoben.


\clearpage
\chapter{Hintergrundwissen}
\section{Das o/ZB Projekt}
Die Solidargemeinschaft o/ZB Stuttgart wurde am 21. Januar 2005 als GbR von 10 GesellschafterInnen gegründet und hatte Mitte des Jahres bereits 100 Mitglieder.
Die o/ZB ist ein regionales Finanzierungsinstrument, das seinen Mitgliedern die Realisierung von Projekten in Selbsthilfe ermöglicht. Anderst als bei klassischen Einrichtungen erfolgen alle Einlagen (z.B. Sparen) und Entnahmen (z.B. Leihen) zinslos und kostenfrei, weil alle anfallenden Arbeiten von ihren Mitgliedern in Selbstverwaltung ausgeführt werden können.

Abbildung \vref{fig:ozb_process} zeigt das von der o/ZB verwendete Dreiphasenkonzept.
\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.65\textwidth]{\string"Media/3PhasenKonzept\string".png}
     \end{center}
     \label{fig:ozb_process}
     \caption{o/ZB Dreiphasenkonzept}
\end{figure} 


\section{Das Testsystem}\label{sec:Das_Testsystem}
% URL, Maschine, Versionen... 
Das Testsystem wird von Alvotech betrieben. Das Kundeninterface ist unter der URL \url{http://www.alvotech.de/kundenlogin} erreichbar. Das Testsytem bietet ein Debian GNU/Linux System, Kernelversion 3.1.2. Darüber hinaus ist ein MySQL Server in der Version 5.1.49-3 installiert. Auch Ruby ist in der Version 1.9.3p392 vorinstalliert.\\
Die Webanwendung liegt im Homeverzeichnis. Durch die Einführung von Capistrano geschieht eine Versionierung der Webanwendung. Ein Symlink \textit{ozbapp} führt aus dem Homeverzeichnis zu der aktuellen Version der Webanwendung. Der Web- und Application Server, der für die Ausführung der Webanwendung zuständig ist, heißt \textit{Phusion Passenger} und wird in der Version 3.0.19 verwendet (s. \url{https://www.phusionpassenger.com/}). Die Webanwendung ist unter der URL \url{http://ozbapp.mooo.com/} erreichbar. Der Code liegt in einem Git Repository auf GitHub (\url{https://github.com/Avenel/FirstApp}). Details zu den einzeln genannten Softwaretechnologien können dem Kapitel \ref{sec:deployment} entnommen werden.


\section{Test-Driven Development}
\subsection{Definition}
\textit{Test-driven Development} (engl. für \glqq Testgetriebene Entwicklung\grqq) ist eine Entwicklungsmethode die besonders in Unternehmen, die agile Softwareentwicklungsmethoden anwenden, Anwendung findet. Der Entwicklungsprozess ist recht klein gehalten und verfolgt einen fest definierten Ablauf. Der Ablauf sieht vor, dass zunächst der Test für eine gewünschte Funktionalität geschrieben wird und im Anschluss daran wird der Programmcode geschrieben, der dafür sorgen soll das der Test korrekt abgeschlossen wird. Die nachfolgende Figur \vref{fig:tdd_process} zeigt den gewünschten Ablauf noch einmal im Detail.

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.65\textwidth]{\string"Media/Test-driven_development\string".png}
     \end{center}
     \label{fig:tdd_process}
     \caption{Testdriven Development Prozess}
\end{figure} 

Diese Entwicklungsmethode stiftet die Programmierer dazu an, sehr schlanken (engl. \glqq dry\grqq) Programmcode zu schreiben und einen anderen Blick auf die Anwendung zu erhalten. Darüber hinaus steigert es während der Entwicklungsphase das Selbstbewusstsein des Programmierers, denn er kann mit Hilfe der Tests den Zustand der Anwendung schnell überblicken und sich sicher sein das sein Programmcode funktioniert - auch wenn der Umfang der Anwendung ansteigt. Außerdem steigert diese Entwicklungsmethode die Code-Qualität enorm und führt zu einer Steigerung der Produktivität des Entwicklerteams.\\

Es gibt verschiedene Arten von Tests, die auf verschiedenen Ebenen agieren. In den nachfolgenden Abschnitten werden diese kurz dargestellt und in einen Zusammenhang gebracht. Dabei wird auf die Vorgehensweise bei einer Ruby on Rails Webanwendung Rücksicht genommen. 

\subsection{Modul Tests}
\textit{Modul Tests}, oder auch \textit{Unit Tests}, sind Tests die die einzelnen Komponenten, bzw. Entitäten einer Anwendung testen. Das Ziel dieser Tests ist es, die sowohl fachliche als auch technische korrekte Funktionalität sicherzustellen. Die Tests stellen einen Vertrag dar, die das zu testende Modul erfüllen muss. Diese Testart ist ganz nach vorn im Testprozess einzuordnen und ist die Voraussetzung dafür um mit den Controller Tests fortfahren zu können. Ein Modul ist somit die kleinst zu testende Einheit in einer Anwendung. Ein Modul Test soll sicherstellen, dass jedes kleine Teil eines Ganzen für sich allein gesehen korrekt funktioniert, sodass das eine Anwendung auf einer soliden Basis aufbauen kann. Bei der Implementierung eines Modul Tests ist zu beachten, dass das zu testende Modul isoliert getestet wird. D.h. es dürfen keine Modulübergreifende Interaktionen implementiert werden. Außerdem testen Modul Tests gemäß des \glqq Design-by-Contract\grqq Prinzips nicht die interne Umsetzung des Moduls, sondern ihre Ausgaben bei verschiedenen Eingaben.

\subsection{Controller Tests}
Der nächste Schritt besteht darin, die Funktionen eines Controllers zu testen. Ein \glqq Controller Test\grqq ist im Grunde nicht viel anders als ein Modul Test, allerdings werden hierbei auch die Interaktionen der verschiedenen Module untereinander getestet, falls der Controller dies leisten soll. Das Ziel ist die Sicherstellung, dass bei fest definierten Benutzereingaben die gewünschte Reaktion geschieht. Auch bei einem Controller Test werden alle Funktionen isoliert getestet. In der Testhierarchie besetzt der Controller Test die mittlere Position, zwischen den Modul Tests und den nun dargestellten Feature Tests.


\subsection{Feature Tests}
Ein sogenannter \glqq Feature Test\grqq ist in etwa vergleichbar mit einem \glqq Integration Test\grqq. Der Feature Test überprüft das Zusammenspiel der verschiedenen Controller. Darüber hinaus werden Testszenarien festgelegt, in denen reale Benutzerinteraktionen beschrieben werden um zu sehen wie die Webanwendung auf diese reagiert. Somit können die Interaktionen eines Benutzers mit der Webanwendung vollständig nachvollzogen werden. Die Benutzerinteraktionen werden vom Testsystem emuliert und generieren Benutzereingaben, die von den Controllern verarbeitet werden. Hier zeigt sich der Unterschied zu den vorher vorgestellten Controller Tests, denn dort sind die Eingaben bereits festgelegt. Mit Hilfe der Feature Tests können somit weite Bereiche einer Webanwendung getestet werden und sind u.a. ein beliebtes Hilfsmittel um bei Bug-Reports ein Testszenario zu beschreiben.

\clearpage
\chapter{Allgemeine Dokumentationen}
\section{Das korrigierte ER-Diagramm}

Das Entity Relationship Diagramm (s. \vref{fig:er_diagramm}) wurde hauptsächlich aus fachlicher Sicht gestaltet. Es repräsentiert die nicht-historisierte Assoziation zwischen den Entitäten. Entitäten, welche historisiert werden, beinhalten als Attribut \glqq GÜLTIG VON\grqq. Der bzw. die Primary Keys sind \underline{unterstrichen} Dargestellt. Die Foreign Keys hingegen werden nach ihrem Attributnamen mit \glqq (FK)\grqq\ gekennzeichnet.\\
Die Hauptunterschiede, die seit der letzten Version aufgetreten sind, beinhaltet Korrekturen der Assoziationen, neue Tabellen wie \glqq Währung\grqq und \glqq Umlage\grqq\ sowie die deutliche Kennzeichnung der Attribute. Außerdem ist das ER-Diagramm nun in einer editierbaren Form vorhanden und kann mit der frei verfügbaren und unter Windows, Unix/Linux und Mac OS X laufenden Anwendung \textit{yEd Graphic Editor}\footnote{\url{vgl. http://www.yworks.com/de/products_yed_about.html}} bearbeitet werden. 

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=\textwidth]{Media/er_diagramm.pdf}
     \end{center}
     \caption{Entity Relationship Diagramm}
     \label{fig:er_diagramm}
\end{figure} 

%[Insert content, Micha]
% Wie sieht es aus?
% Was wurde angepasst?
% Beschreibung der Veränderungen am Code

\section{Das korrigierte Relationenmodell}
Während der Anfertigung der Unit-Tests ist aufgefallen, dass nicht alle Attribute in ihrer Gültigkeit spezifiziert worden sind. Aufgrund dessen mussten die o/ZB-Attribute überprüft und dementsprechend angepasst werden. Ebenso ergaben sich durch Änderungen am ER-Diagramm, Änderungen am Relationenmodell. Die Liste, der gemeinsamen Ausarbeitung aus dem Meeting vom 19.07.2013, befindet sich im Anhang (s. \vref{chapter:ozb_attribute}).

\section{Deployment und Versionskontrolle}
In diesem Abschnitt werden die Begriffe \textit{Deployment} und \textit{Versionskontrolle} erläutert. In jedem Teilabschnitt wird die aktuelle Umsetzung beschrieben. Der letzte Teil dieses Abschnitts beschäftigt sich mit dem \textit{Commit \& Deployment Workflow}.

\subsection{Deployment}\label{sec:deployment}
% Was ist das? Deployment - Capistrano, Versionskontrolle - Git
In der Softwareentwicklung wird unter dem Begriff \textit{Deployment} der Prozess zur \textit{Bereitstellung} und \textit{Verteilung} einer Software verstanden. Der Prozess ist von Software zu Software unterschiedlich, da z.B. die Konfiguration einer Software immer an die Umgebung angepasst werden muss, in der diese zum Einsatz kommt.\\

Im Falle der o/ZB muss der Deployment Prozess die Bereitstellung der o/ZB Webanwendung auf einem Server bewerkstelligen. Dies wirft die folgenden Fragen auf: Welcher Webserver wird eingesetzt? Wie gelangt die RoR Webanwendung auf den Server? Und wie arbeiten Anwendungsserver und Webserver auf dem Server zusammen? Diese Fragen werden die nun folgenden Teilabschnitte (kurz) klären.

\subsubsection{Webserver - Apache}
Ein Webserver überträgt Daten an einen Client. Dabei kann dieser die Daten nur lokal oder auch weltweit zur Verfügung stellen. Er dient im Falle der o/ZB Webanwendung dazu, die von RoR erzeugten Webseiten an den Clienten auszuliefern. Dies geschieht sobald er die Anfrage eines Clienten aufgenommen und an die RoR Anwendung weitergeleitet hat. Daraufhin verarbeitet die RoR Anwendung diese Anfrage und liefert dem Webserver das Ergebnis zurück. Der Webserver sendet nun diese Daten an den Clienten.\\

Auf dem Testsystem der o/ZB (s. \vref{sec:Das_Testsystem}) kommt ein Apache Webserver in der Version 2.2.16 zum Einsatz. Auf dem Testsystem laufen bis zu vier Apache Instanzen gleichzeitig, um die Anfragen der Benutzer bedienen zu können. Weitere Informationen zum Apache Webserver sind unter der Adresse \url{http://www.apache.org} erreichbar.

\subsubsection{Anwendungsserver - Phusion Passenger}
Ein \textit{Anwendungsserver} bietet einer Anwendung die benötigte Laufzeitumgebung, damit diese auch ausgeführt werden kann. Dazu stellt der Anwendungsserver der Anwendung spezielle Dienste zur Verfügung, die die Anwendung zur Ausführung benötigt.\\
Im Fall der o/ZB Webanwendung wird der weit verbreitete und leistungsstarke \textit{Phusion Passenger} Anwendungsserver in der Version 3.0.19 genutzt. Phusion Passenger ist ein Modul für den Apache Webserver und ist als ein sogenanntes \textit{RubyGem} (entspricht etwa einem Softwarepaket speziell für Ruby) verfügbar. Zudem ist es auch unter dem Namen \textit{mod\_rails} oder \textit{mod\_rack} bekannt. Weitere Informationen können auf der Webseite von Phusion \url{https://www.phusionpassenger.com/} entnommen werden. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Phusion_Passenger}}

\subsubsection{Capistrano}
Wie Eingangs dieses Abschnittes erwähnt worden ist, sind bei einem Deployment Prozess die Schritte notwendig, die die Bereitstellung der Software bewerkstelligen. Diese Schritte müssen nicht immer manuell ausgeführt werden, sondern können automatisiert werden. Dafür eignet sich im Falle der o/ZB Webanwendung die Software \textit{Capistrano}. Diese Software ist ein Open Source Werkzeug, das (Batch-) Skripte auf Servern, z.B. mit der Hilfe einer \textit{Secure Shell (SSH)}, ausführt. Dem zur Folge ist ihr Haupteinsatzzweck in der Softwareverteilung wiederzufinden. Capistrano ist genauso wie die o/ZB Webanwendung auch in Ruby geschrieben und als RubyGem verfügbar. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Capistrano_(Software)}}\\

Bei Capistrano bestimmen sogenannte Deployment Rezepte (\glqq Deployment Recipies\grqq) wie der Deployment Prozess verläuft. Auch für die o/ZB Webanwendung wurde ein Rezept geschrieben, welches im Abschnitt \vref{subsec:deployment_recipe} beschrieben wird.

\subsection{Versionsverwaltung}
Für einen stabilen und guten Softwareentwicklungsprozess ist eine Versionsverwaltung in der heutigen Zeit unabdingbar. Die Hauptaufgaben bestehen aus der Protokollierung der vorgenommenen Änderungen an Quelltexten, Skripten und anderen Dokumenten. Der Wiederherstellung von alten Zuständen, sodass versehentliche Änderungen oder Änderungen, die z.B. zu Laufzeitfehlern führten, zurückgenommen werden können. Die Archivierung jedes neuen Projektzustands. Die Koordinierung des gemeinsamen Datei-Zugriffs der am Projekt beteiligten Entwickler. Und zu guter Letzt ermöglicht eine Versionsverwaltung die gleichzeitige Erzeugung mehrerer Entwicklungszweige (sogenannter \glqq Branches\grqq) eines Projektes. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Versionsverwaltung}}

\subsubsection{Git}
% Wie sieht aktuelle Setup aus?
Für das Projekt der o/ZB Stuttgart wird die weit verbreitete, freie Software \textit{Git} verwendet. Es wurde ursprünglich für die Quelltext-Verwaltung des Linux Kernels entwickelt.\\
Git ist im Gegensatz zu den Traditionellen Versionsverwaltungen wie z.B. \textit{SVN} oder \textit{Mercurial} ein verteiltes Versionsverwaltungssystem. Es gibt keinen zentralen Server auf dem das Projekt gespeichert wird, sodass jeder Entwickler eine lokale Kopie des gesamten Repositorys vorliegen hat - \textit{clone}. Dem zur Folge hat der Entwickler die Möglichkeit auch ohne Netzwerkzugriff die einzelnen Zustände seiner Arbeit festzuhalten - \textit{commit}. Besteht wieder ein Netzwerkzugriff kann er seine Änderungen auf das von den Entwicklern gemeinsam genutztes Projekt-Depot (\textit{Repository}) hochladen - \textit{push}. Zuvor muss er sich jedoch mit dem gemeinsamen Repository synchronisieren - \textit{pull}. \footnote{vgl. \url{http://de.wikipedia.org/wiki/Git}}\\

Das aktuelle, gemeinsame Repository des o/ZB Projektes wird von dem bekannten Git-Hoster \textit{GitHub} bereitgestellt. Die Adresse zum Repository lautet: \url{https://github.com/Avenel/FirstApp}.

\subsection{Workflow, Umsetzung}
% Workflow: Git add/commit/push, cap deploy
In diesem Teilabschnitt werden die vorher erläuterten Konzepte \textit{Deployment} und \textit{Versionsverwaltung} in Zusammenhang gebracht. Es wird ein Arbeitsablauf (\glqq Workflow\grqq) defininert, der den Deployment Prozess beschreibt. Dieser Arbeitsablauf wird in Abbildung \vref{fig:deployment_workflow} dargestellt.

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.90\textwidth]{\string"Media/Deployment Workflow\string".pdf}
     \end{center}
     \caption{Der Deployment Workflow}
     \label{fig:deployment_workflow}
\end{figure} 

Möchte der Entwickler seine Arbeit auf dem Server bereitstellen, ist er angehalten sich den aktuellen Projektstatus aus dem gemeinsamen Repository zu holen. Er ist dafür verantwortlich sein Projekt vor jedem Commit auf den neuesten Stand zu bringen. Dies geschieht mit der Anweisung \textit{git pull}. Kommt es zu (Datei-) Konflikten die Git nicht automatisch selber lösen kann, muss der Entwickler selber eingreifen (\textit{merge}). Er wiederholt diesen Vorgang solange, bis sein Projekt konfliktfrei und auf dem neuesten Stand ist. Erst dann kann er ausgewählte Änderungen am Projekt für einen neuen \textit{Commit} hinzufügen (\textit{git add}). Im Anschluss schließt er den Commit-Prozess mit dem Befehl \textit{git commit -am "Kommentar"} ab. Damit auch das gemeinsame Repository auf den aktuellsten Stand gebracht wird, erfolgt der Befehl \textit{git push}. Dieser lädt die neuesten Änderungen hoch.\\

Wurde das gemeinsame Repository nun auf den neuesten Stand gebracht, kann der letzte Schritt im Deployment Workflow durchgeführt werden. Mit \textit{cap deploy} wird das, im nächsten Abschnitt beschriebene, Deploymentskript ausgeführt. 

\subsubsection{Das Capistrano Deploymentskript (Rezept)}\label{subsec:deployment_recipe}
Das Capistrano Deploymentskript bzw. Rezept ist vorerst nicht im öffentlich zugänglichen Git Repository zu finden, da es durchaus sensible Informationen enthält. Ist es vorhanden befindet es sich hier: \textit{config/deploy.rb}.\\
In dem Deploymentskript werden zuerst sämtliche Variablen festgelegt, der Name der Anwendung und die für einen sicheren SSH Zugriff notwendigen Daten (Serveradresse, sowie auch der Deployment-Benutzer: \glqq ozbapp\grqq). Darüber hinaus werden Informationen zum Repository angegeben, in dem die Projektdateien liegen. Im Anschluss wird der Deployment Ort auf dem Server, sowie eigene Aktionen während des Deployment Vorgangs festgelegt.

\begin{lstlisting}[frame=single, caption=Capistrano Deployment Rezept, tabsize=2, flexiblecolumns=true, captionpos=b]{Deploy.rb}
# Name application
set :application, "ozbapp"

# Setup deployment user and server ip
server "188.64.45.50", :web, :app, :db, :primary => true
set :user, "ozbapp"
set :use_sudo, false
ssh_options[:forward_agent] = true

# Setup git repository information
set :scm, "git"
set :repository, "https://github.com/Avenel/FirstApp.git"
set :branch, "master"

# Setup where to deploy the app on the server
set :deploy_to, "/home/#{user}/apps/#{application}"
set :deploy_via, :remote_cache

namespace :deploy do

     desc "Tell Passenger to restart the app."
     task :restart do
          run touch "#{current_path}/ozbapp/tmp/restart.txt"
     end

     desc "Renew SymLink"
     task :renew_symlink do
          run "rm /home/ozbapp/ozbapp"
          run "ln -s /home/ozbapp/apps/ozbapp/current/ozbapp /home/ozbapp/ozbapp"
     end

end

# Execute renew_symlink after update_code
after 'deploy:update_code', 'deploy:renew_symlink'
\end{lstlisting}

\clearpage
\section{Datenbank Migration}
% Welche Skript gibt es und was tun diese?
% Wie wird das auf dem Server ausgeführt?
In der vergangenen Zeit wurde ein Java Datenbank Migrationstool geschrieben, welches die Daten von dem aktuellen Produktivsystem in das neue System übertragen soll. Um den Umgang mit diesem Tool zu erleichtern sind zwei Batch Skripte angefertigt worden. Diese Batch Skript sind im Ordner \textit{tools} des Git Repositorys und auch auf dem Server im \textit{Home Verzeichnis ozbapp} zu finden. Um die Batch Skripte ausführen zu können ist eine SSH Verbindung erforderlich. Diese kann unter Windows mit dem Programm \textit{Putty} (\url{http://www.putty.org/}) oder unter Linux mit dem Befehl \textit{ssh username@host} (\url{http://wiki.ubuntuusers.de/SSH}) geöffnet werden. Der Username bzw. der Hostname ist in beiden Fällen \textit{ozbapp} bzw. \textit{ozbapp.mooo.com}. Die benötigte Konfiguration für Putty ist der Abbildung \vref{fig:putty_config} zu entnehmen. Ist man verbunden befindet man sich automatisch schon im \textit{Home Verzeichnis} in dem die Batch Skripte vorliegen.\\ 

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.60\textwidth]{\string"Media/putty_configuration\string".png}
     \end{center}
     \caption{Putty Konfiguration}
     \label{fig:putty_config}
\end{figure} 

\begin{figure}[H]
     \begin{center}
          \includegraphics[width=0.60\textwidth]{\string"Media/putty_open_session\string".png}
     \end{center}
     \caption{Offene SSH Session in Putty}
     \label{fig:putty_open_session}
\end{figure} 

Im Folgenden werden die Funktionsweise und die Benutzung dieser beiden Batch Skripte beschrieben. 

\subsection{Datenbank migrieren}
Dieses Batch Skript importiert zunächst einen aktuellen Stand der Produktivdatenbank, der als MySql Dump zur Verfügung gestellt wird, in die auf dem Testserver liegende Produktivdatenbank \textit{ozb\_prod}. Im Anschluss wird die Testserver Testdatenbank \textit{ozb\_test} geleert und neu angelegt. Ist dies geschehen, werden mit Hilfe des Datenbank Migrationstools die Daten aus der Produktivdatenbank \textit{ozb\_prod} in die Testdatenbank \textit{ozb\_test} übertragen. Das neue Datenbankschema wird in der Datei \textit{create\_tables.txt} beschrieben. Sind Veränderungen am Datenbankschema vorgenommen worden, müssen diese in dieser Datei übernommen werden. Ausgeführt wird dieses Skript mit dem Befehl \textit{./datenbank\_migrieren.sh}.\\

\lstinputlisting[language=bash, frame=single, caption=datenbank\_migrieren.sh, tabsize=2, flexiblecolumns=true, captionpos=b]{\string"../tools/datenbank_migrieren\string".sh}

\subsection{Datenbank zurücksetzen}
In diesem Batch Skript wird die Testdatenbank auf den ursprünglichen Zustand zurückgesetzt. Der ursprüngliche Zustand liegt in dem MySQL Dump \textit{dump.sql}. Zur Ausführung genügt auch hier der folgende Befehl \textit{./datenbank\_ruecksetzen.sh}. \\

\lstinputlisting[language=bash, frame=single, caption=datenbank\_migrieren.sh, tabsize=2, flexiblecolumns=true, captionpos=b]{\string"../tools/datenbank_ruecksetzen\string".sh}

\clearpage
\chapter{Korrekturen, Bugfixes}
% WebImport
\section{Webimport}
In der o/ZB Webanwendung sorgt der sogenannte \textit{Webimport} für die Übertragung der in einer CSV Datei hinterlegten Kontobewegungen. Weitere Informationen zu dem Webimport kann der Projekt Dokumentation WS 12/13 (ab S.53) entnommen werden.\\

Zum Zeitpunkt der Aufnahme der Arbeiten an diesem Projekt funktionierte der Webimport nicht korrekt. Die folgenden Punkte sind aufgefallen:

\begin{itemize}
     \item{Datei Upload auf dem Testsystem funktioniert nicht.}
     \item{Laufzeitfehler müssen abgefangen werden.}
     \item{Die Anzahl der importierten Datensätze stimmt nicht.} 
\end{itemize}

\subsection{Bugfix: Datei Upload}
Bei diesem Fehler akzeptierte der Webimport scheinbar keine Datei. Der Grund hierfür liegt in den abgebildeten Zeilen in Listing \vref{listing:webimport_nil}.\\

\lstinputlisting[language=Ruby, frame=single, caption=webimport\_controller.rb, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=423, lastline=427]{\string"../ozbapp/app/controllers/webimport_controller\string".rb}\label{listing:webimport_nil}

In Zeile 4 (bzw. Zeile 426) wurde ursprünglich der Befehl \textit{uniq!} verwendet. Methoden mit einem Ausrufezeichen (!) benutzen meistens eine unsichere Implementierungsweise der Methode. Dieser Befehl gibt laut der offiziellen RubyDoc \footnote{vgl. \url{http://www.ruby-doc.org/core-1.9.3/Array.html\#method-i-uniq-21}} entweder ein \textit{Array} oder \textit{nil} zurück. Der Rückgabewert \textit{nil} tritt ein, sobald das Array keine Elemente vorweisen kann. Da dieser Fall nicht abgefangen worden ist, kommt es in der Zeile 4 (bzw. 426) zu einem Fehler. Abhilfe schafft hier die Methode \textit{uniq}. Diese gibt in jedem Fall ein (ggf. leeres) \textit{Array} zurück. 
\subsection{Laufzeitfehler}
Konnte ein Datensatz z.B. aufgrund eines MySql Fehlers nicht importiert werden, wird eine Exception geworfen. Aufgrund dieser Exception wurde der Importvorgang nicht korrekt zu Ende geführt, sondern direkt abgebrochen. Der Benutzer sieht in diesem Moment eine Fehlerseite und kann nicht mehr agieren, da er keine Informationen darüber erhält, was schiefgegangen ist. Der häufigste Fehler tritt auf, wenn versucht worden ist eine Buchung noch ein weiteres Mal zu importieren (MySql Fehler: \textit{duplicate key error}). Nun gilt es mit Hilfe des Exception Handlings das Verhalten der Webanwendung zugunsten des Benutzers zu beeinflussen.\\

Die Exceptions treten beim Speichervorgang auf, dem zur Folge wurde um jeden Speichervorgang ein \textit{begin-rescue} Block gesetzt. Dieser fängt die Exception auf und hängt die Fehlermeldung der \textit{@error} Variable an. Diese stellt dem Benutzer ggf. die Informationen darüber, was schiefgelaufen ist, dar.\\

\lstinputlisting[language=Ruby, frame=single, caption=webimport\_controller.rb, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=278, lastline=285]{\string"../ozbapp/app/controllers/webimport_controller\string".rb}\label{listing:webimport_nil}


\subsection{Anzahl der importierten Datensätze}
Eine weitere Auffälligkeit bestand in der angezeigten Anzahl der importierten Datensätze. Diese Zahl zeigte ggf. zu viele importierten Datensätze an. Unter einem Datensatz versteht man eine Kontobewegung in der CSV Datei.\\

Einer der Fehler tritt in Zeile 318 auf. Dort werden bei einer bestimmten Kontobewegung zwei Buchungen durchgeführt. Beide Buchungen wurden mitgezählt, obwohl der Auslöser nur \textit{ein} Datensatz gewesen ist. Durch Auskommentieren und einem Hinweis konnte dieser Fehler korrigiert werden.\\

\lstinputlisting[language=Ruby, frame=single, caption=webimport\_controller.rb, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=313, lastline=321]{\string"../ozbapp/app/controllers/webimport_controller\string".rb}\label{listing:webimport_nil}


\subsection{Punkteberechnung}
Beim Import der Buchungen werden zum Zeitpunkt der Übernahme noch keine Punkte berechnet. Im Zuge der Modul Tests wurden die mit dem Webimport verbundenen Module nochmals überarbeitet. Auf Grund des immensen Arbeitsaufwands, der in das Refactoring gesteckt werden musste, wurde eine erneute Implementierung der Punkteberechnung im Rahmen dieser Projektarbeit nicht in Betracht gezogen. 

% Darlehensverlauf
\section{Darlehensverlauf}
Der Darlehensverlauf ist zum Zeitpunkt der Übernahme fehlerhaft gewesen. Im Zuge in den von Herrn Kienle angefertigten Tests, konnten die aufgetretenen Fehler analysiert und kategorisiert werden. Aufgrund des relativ unstrukturierten und unübersichtlichen Programmcodes, wurde beschlossen diese Funktionalität, basierend den Spezifikationen die sich aus den Tests und Dokumentationen ableiten ließen, neu zu implementieren.\\

\textbf{Fehlerursachen:}

\begin{itemize}
     \item{Punkte wurden nicht richtig berechnet, wenn am Tage des abDatums noch Buchungen getätigt wurden}
     \item{Die Sortierung der Buchungen stimmte nicht mit den Vorgaben überein}
     \item{Wiederverwendete ZE Konten wurden nicht richtig berücksichtigt}
     \item{Startsaldo wurde nicht korrekt berechnet, da die Tagesdifferenz zur letzten Währungsbuchung nicht berücksichtigt wurden}
     \item{Die Punkte die bei der Buchung nach dem Startsaldo berechnet wurden, sind falsch da diese einfach aus der DB entnommen wurden}
     \item{Variable KKL-Verläufe, KKL veränderte sich während des abgefragten Zeitraumes}
\end{itemize} 

% Lösung
Diese Ursachen wurden bei der kompletten Neu-Implementierung beachtet und umgesetzt. Integrationstest, beschrieben in Kapitel \ref{} sichern die korrekte Funktionalität in den gegebenen Anwendungsfällen.

\section{HistoricRecord}
Im Zuge des Test-Driven Development und dem damit verbundenen Refactoring, ist aufgefallen das für jedes historisierte Model im Grunde derselbe Quellcode geschrieben wurde, der für die Historisierung zuständig gewesen ist. Dieser lässt sich nur sehr schlecht warten und im allgemeinen ist großer, redundanter Quellcode, wie hier vorgefunden wurde, schlecht. Daher wurde ein neues Ruby-Modul implementiert: \textit{HistoricRecord}. Dieses Ruby-Modul lässt sich für jedes Model anwenden, wenn dies die folgenden Methoden implementiert und Kriterien beachtet.\\

\textbf{get\_primary\_keys}\\
Diese Methode liefert den primären Schlüssel, bis auf das Attribut GueltigVon (dies ist in jedem primären Schlüssel einer historisierten Klasse enthalten). Abbildung \vref{listing:getPrimaryKeys} zeigt eine beispielhafte Implementierung.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=11, lastline=13]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:getPrimaryKeys}

\textbf{set\_primary\_keys}\\
Die Methode \textit{set\_primary\_keys(values)} erwartet die Werte für den primären (zusammengesetzten) Schlüssel. Nach Aufruf entsprechen die Werte der Primärschlüssel Attribute den angegebenen Werten. Abbildung \vref{listing:setPrimaryKeys} zeigt eine beispielhafte Implementierung.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=15, lastline=17]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:setPrimaryKeys}

\textbf{getLatest}\\
Die Methode \textit{getLatest} liefert die aktuellste Version der Model Instanz zurück, bevor die Änderungen abgespeichert werden. Sie ist notwendig, um die GueltigBis Zeit für diese Instanz neu zu setzen. Abbildung \vref{listing:getLatest} zeigt eine beispielhafte Implementierung.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=132, lastline=134]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:getLatest}

\textbf{Attribute: GueltigVon, GueltigBis}\\
Diese Attribute müssen auf jeden Fall vorhanden sein, sowohl als \textit{accessible attribute} als auch in der Datenbank. \\

Sind diese Voraussetzungen erfüllt, muss das Modul noch eingebunden werden. Da Ruby keinen \textit{Polymorphismus} (Mehrfachvererbung) unterstüzt, wird \textit{Duck typing} (s. \url{http://en.wikipedia.org/wiki/Duck_typing}) angewandt. Abbildung \vref{listing:duckTyping} zeigt, wie es geht.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=2, lastline=5]{\string"../ozbapp/app/models/ozb_konto\string".rb}\label{listing:duckTyping}


\section{Umzug der Benutzerattribute in die Tabelle User}
Im Zuge der Korrektur des ER-Diagramms, ist der Wunsch nach einer Trennung zwischen den technischen und fachlichen Attributen in der Tabelle \textit{OZBPerson} aufgekommen. Somit ist eine weitere, rein technische, Tabelle \textit{Users} entstanden. Diese Tabelle wurde mit Hilfe von Devise (Gem für Login, Sessionmanagement) generiert. Jedes OZBMitglied, und deren Partner, erhalten einen eigenen Login. Die ID in der Tabelle Users entspricht der Mnr in der Tabelle OZBPerson, sodass ein einfaches Mapping erfolgen kann.

\clearpage
\chapter{Testdriven Development}
In diesem Kapitel wird die Einführung und Durchführung der Eigenschaften der testgetriebenen Entwicklung beschrieben. Im Zuge dessen wird zunächst eine Analyse des Ist und des Soll Standes durchgeführt, bevor mit der Umsetzung und Durchführung fortgefahren wird. Das Ziel ist die Einführung und Durchführung von Tests, um den Zustand der Webanwendung darzulegen und um die aufgezeigten Mängel zu beseitigen und mit Hilfe der Tests nicht wieder eintreten zu lassen.    

\section{Analyse}
% Ist-Analyse: Es gibt keine Tests, Fehlerbehaftete Anwendung
\subsection{Ist-Stand}
Der Ist-Zustand der vorliegenden Webanwendung ist zum Zeitpunkt der Übernahme nur schwer überschaubar. Es gibt viele neue Funktionalitäten und Testberichte die deutliche Mängel aufzeigen. Die vorliegenden Dokumentationen beschreiben die neuen Funktionalitäten und deren Umsetzung, allerdings fehlt ein Überblick über den Gesamtzustand der Webanwendung. Es wurden nur einzelne, wichtige, Funktionalitäten getestet. Allerdings handelt es sich hierbei um Frontend Tests, die jedoch keine ausreichenden Aussagen über die fachliche und technische Korrektheit der Module und deren Beziehungen untereinander liefern können.\\

Um gültige Aussagen über den Zustand dieser Webanwendung treffen zu können, sind umfangreiche Modultests der erste Schritt. Diese liefern den Zustand über die einzelnen Module, bzw. Entitäten wie z.B. Person, OZBPerson, OZBKonto usw. zurück. Auch liefern diese Aussagen über die Korrektheit der Umsetzung des vorgegeben Datenmodells. Hier sind auf dem ersten Blick bereits einige Unstimmigkeiten aufgefallen.\\

% Soll-Analyse: bugfrei durch TDD. Was müssen wir dafür testen?
\subsection{Soll-Stand} 
Ein erster Meilenstein stellt die korrekte Umsetzung des fachlichen Datenmodells dar. Dazu gehört, dass jedes Model den fachlichen Beschreibungen entspricht und sauber implementiert wurde. Im Idealfall ist die Struktur aller Module gleich, der Code auf ein Minimum reduziert und konsistent hinsichtlich z.B. der Attributsnamen und der Art und Weise wie bestimmte Funktionalitäten (wie z.B. die Suche nach einer Modulinstanz) implementiert wurden. Die Modul Tests gewährleisten hierbei die fachlich korrekte Umsetzung. Auf die technisch konsistente Umsetzung der Module muss der Entwickler selbst achten.\\
Der nächste Meilenstein stellt eine einheitliche, technisch und fachlich korrekte Implementierung der Controller und den dazugehörigen Views dar. Hierbei stellt die korrekte Umsetzung der Module das Standbein und somit auch die notwendige Weiche für diesen Meilenstein. Hierbei gewähren die Controller Tests eine fachlich korrekte Umsetzung, ehe sich die Feature Tests auch von der korrekten Umsetzung in einem konkreten Anwendungsfall, der mehrere Controller involviert, überzeugen kann.

\section{Implementierung}
In diesem Abschnitt wird die Umsetzung der Tests beschrieben. Dazu gehört eine kurze Zusammenfassung aller benutzten Gems und wie sie eingesetzt wurden. Im Anschluss werden nacheinander Modul und Controller Tests vorgestellt. Dabei werden Aufbau und Funktionsweise anhand von Beispielen erläutert. Darüber hinaus gibt es eine Auflistung in der alle getesteten Modulen verzeichnet sind.
\subsection{Verwendete Gems}
\subsubsection{RSpec}
\textit{RSpec} (s. \url{http://rubygems.org/gems/rspec}) ist das wohl bekannteste Testing-Framework für Ruby on Rails Applikationen. Es ist im Sinne des \textit{Behaviour-Driven Development} entstanden und soll das Test-Driven Development unterstützen und leichter zugänglich machen. Das Verzeichnis \textit{/spec} birgt alle Dateien, die mit dem Testing in Verbindung stehen.

\subsubsection{FactoryGirl}
\textit{Factory\_girl} (s. \url{http://rubygems.org/gems/factory_girl}) stellt ein alternatives Framework zu den Ruby Fixtures zur Verfügung, das es erlaubt Daten mit Hilfe einer \glqq Factory\grqq (=Fabrik, s. \url{http://de.wikipedia.org/wiki/Abstract_Factory}) zu generieren. In dieser Webapplikation lassen sich somit Beispieldaten für die Tests leichter erzeugen. Abbildung \vref{listing:default_factory} zeigt einen Ausschnitt einer typischen Factory.  

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=3, lastline=12]{\string"../ozbapp/spec/factories/adressen\string".rb}\label{listing:default_factory}

\subsubsection{Faker}
\textit{Faker} (s. \url{https://rubygems.org/gems/faker}) ist ein Tool für die Erzeugung von Fake Adressen, Namen, Telefonnummern und mehr. Dieses Gem ergänzt sich prima mit den oben genannten Factories. Eine detaillierte Beschreibung aller Möglichkeiten können unter der folgenden URL entnommen werden: \url{http://rubydoc.info/github/stympy/faker/master/frames}.

\subsection{Gems die zukünftig verwendet werden könnten}
In diesem Abschnitt werden Gems genannt, die in Zukunft den Test-Driven Development unterstützen könnten.
\subsubsection{Capybara}
\textit{Capybara} (s. \url{http://rubygems.org/gems/capybara}) hilft, die Benutzerinteraktionen mit der Web-Applikation zu simulieren. Somit lassen sich Integrations Tests implementieren, die noch enger mit der Weboberfläche verzahnt sind.

\subsubsection{Guard-Spec}
\textit{Guard-spec} (s. \url{http://rubygems.org/gems/guard-rspec}) dient dem Entwickler dazu, Tests automatisch (z.B. nach jedem Speichervorgang) auszuführen. 

\subsection{Entwicklertools}
In die Auswahl der Entwicklertools wurde viel Zeit investiert, die im Nachhinein durch gute Auswahl wieder eingespart wurde. Um den nachfolgenden Studenten diesen Aufwand zu ersparen, werden in diesem Abschnitt die verwendeten Entwicklertools kurz aufgelistet und erläutert. 

\subsubsection{Sublime Text 2}
\textit{Sublime Text 2} (s. \url{http://www.sublimetext.com/}) hat sich als ein sehr guter Texteditor (ähnlich VI und Textmate) herausgestellt. Er ist einfach zu bedienen, kann aber genauso viel wie seine Vorbilder. Durch Plugins kann der Funktionsumfang laufend erweitert werden. Diese fügen sich weniger aufdringlich in die Benutzeroberfläche ein (wie z.B. bei Notepad++). Weitere Links zu hilfreichen Webseiten können dem Wiki des Repositories entnommen werden (s. \url{https://github.com/Avenel/FirstApp/wiki/Sublime-Text-Setup}).
Welche Plugins für das Test-Driven Development verwendet wurden, kann dem nun folgenden Abschnitt entnommen werden. 

\subsubsection{RubyTest}
\textit{RubyTest} (s. \url{https://github.com/mhartl/rails_tutorial_sublime_text}) ist ein Sublime Text 2 Plugin, dass den Entwickler bei der Ausführung der Tests hilft. Wie die Installation von statten geht und wie das Plugin benutzt wird, kann diesem Youtube Video entnommen werden \url{http://www.youtube.com/watch?v=05x1Jk4rT1A}. Man hat die Möglichkeit entweder alle Tests eines geöffneten Dokuments mit der Tastenkombination \textit{STRG+SHIFT+T}, oder nur einen einzelnen Test (in dem sich der Cursor befindet) mit der Tastenkombination \textit{STRG+SHIFT+R} auszuführen.


\subsubsection{Cygwin}
Falls man unter Windows entwickelt ist \textit{Cygwin} eine sehr gute Alternative zu der herkömmlichen Windows Kommandozeile. Die Standardinstallation von Cygwin, zu finden hier: \url{http://www.cygwin.com/}, reicht in der Regel aus. Der große Vorteil hier ist, dass das Fenster frei skalierbar ist und sich der Text (z.B. die Ausgabe des Serverlogs) leichter lesen und markieren lässt. 

\subsection{Modul Tests}
Ein Modul Test besteht aus drei Teilen:
\begin{itemize}
     \item{Testing der Factory}
     \item{Testing der Attribut-Validierungen}
     \item{Testing der Klassen/Instanz Methoden}
\end{itemize}

\subsubsection{Factory Test}
Wie bereits in einem früheren Abschnitt gezeigt, werden Factories verwendet um Testdaten zu generieren. Damit sichergestellt ist, dass diese auch korrekt funktionieren besteht der erste Test darin, genau dies sicherzustellen. Abbildung \vref{listing:default_test_factory} stellt beispielsweise einen solchen Test dar.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=6, lastline=9]{\string"../ozbapp/spec/models/bank_spec\string".rb}\label{listing:default_test_factory}

\subsubsection{Attribut-Validierungen}
Attribute müssen in den meisten Fällen bestimmten Kriterien entsprechen. Sie dürfen mal nur eine Nummer sein, mal einem bestimmten regulären Ausdruck entsrechen, müssen vorhanden sein oder auch nicht. Wichtig ist, dass man die folgenden Fälle, die Abbildung \vref{listing:default_test_attributes} zeigt abdeckt.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=29, lastline=45]{\string"../ozbapp/spec/models/bank_spec\string".rb}\label{listing:default_test_attributes}

\subsubsection{Klassen/Instanz Methoden}
Jede Klasse besitzt eigene (private) Methoden die auch getestet werden müssen. Das Prozedere ist auch hier dasselbe, man gibt eine Instanz des zu testenden Models vor, führt die Methode aus und erwartet ein Ergebnis.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=82, lastline=87]{\string"../ozbapp/spec/models/person_spec\string".rb}\label{listing:default_test_instance_methods}

Falls die Methode eine private Methode ist, muss die Methode auf den folgenden Wege aufgerufen werden, wie es Abbildung \vref{listing:execute_private_methode} zeigt.

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=337, lastline=338]{\string"../ozbapp/spec/models/ozb_konto_spec\string".rb}\label{listing:execute_private_methode}

\subsubsection{HistoricRecord}
Auch dieses Modul wurde gesondert getestet. Abbildung \vref{listing:historicRecordTestExample} zeigt stellvertretend die Art und Weise, wie jede einzelne Methode getestet wurde. Dabei ist es wichtig, dass zuerst jede einzelne Funktion für sich isoliert getestet wurde, bevor jedes einzelne Model nochmals eigenständig auf die korrekte Funktionsweise hin geprüft wurde.

 \lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=461, lastline=510]{\string"../ozbapp/spec/models/HistoricRecord_spec\string".rb}\label{listing:historicRecordTestExample}


\subsubsection{Gesteste Models}
Die folgenden Models wurden getestet.

\begin{itemize}
     \item{Bank}
     \item{Bankverbindung}
     \item{Buergschaft (Skelett)}
     \item{EEKonto}
     \item{OZBKonto}
     \item{OZBPerson}
     \item{Person}
     \item{Projektgruppe}
     \item{User}
     \item{Waehrung}
     \item{ZEKonto}
\end{itemize}

\subsection{Controller Tests}
Dieser Abschnitt beschäftigt sich mit der Frage: \textit{Wie werden Controller mit Hilfe von RSpec getestet?}. Zu Demonstrationszwecken, wurde hier der Controller \textit{DarlehensVerlauf} genutzt. Die von Herrn Kienle durchgeführten Testfälle, siehe dazu die Testberichte II, IV und Va,   wurden hier größten Teils abgedeckt und sollen zeigen, dass das manuelle Testen durch die automatisierten Tests abgelöst werden kann.


\subsubsection{Anwendungsfälle der einzelnen Tests}
Für jeden Anwendungsfall, kann ein Kontext definiert werden. Dieser dient einer übersichtlichen Implementierung der Testfälle und gibt Aufschluss darüber, worum es in einem Testfall geht. Abbildung \vref{listing:test_contexts} gibt Aufschluss darüber, wie der Controller Test aufgebaut ist.\\

\begin{lstlisting}[language=Ruby, frame=single, caption=Aufbau Controller Test Darlehensverlauf, tabsize=2, flexiblecolumns=true, captionpos=b]
describe DarlehensverlaufController
	describe "GET new"
		context "Show Darlehensverlauf of EEKonto 70073" do
			context "parameters: anzeigen, vonDatum and bisDatum are nil" do
				it "returns the 10 latest buchungen" do
				it "renders the correct view" do
			context "from 01.11.2010 - 05.12.2010" do
				it "shows bookings from 01.11.2010 to 05.12.2010 and correct points and saldi" do
		context "ZEKonto 10073 [Reused]" do
			context "Show from 15.08.2011 - 15.02.2012" do
				it "shows bookings from 15.08.2011 to 15.12.2012 and correct points and saldi" do
		context "ZEKonto 10038 [Reused]" do
			it "shows bookings from 02.02.2011 to 16.11.2012 and correct points and saldi" do
			it "shows bookings from 15.03.2011 to 16.11.2012 and correct points and saldi" do
		
	describe "GET kontoauszug" do
		it "renders the correct template" do

	describe "Class and instance methods" do
\end{lstlisting}\label{listing:test_contexts}

Im Folgenden wird beispielhaft beschrieben, wie ein einzelner Test implementiert wird. Normalerweise besteht ein Test aus der Berechnung des erwarteten Ergebnisses, der Programm Ausführung und dem anschließenden Vergleich des erwarteten Ergebnisses mit dem realen. 

Abbilung \vref{listing:calculate_expected_results} zeigt die Vorbereitung, der Berechnung der zu erwartenden Ergebnisse. Die letzten Kontobuchungen werden geladen, überprüft ob diese auch bestehen, anschließend werden die verschiedenen Tagessaldi mit den Werten aus den Testberichten Herrn Kienles belegt und die erwartete Punkteanzahl in dem vorgegebenen Intervall berechnet.\\

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=76, lastline=93]{\string"../ozbapp/spec/controllers/DarlehensverlaufController_spec\string".rb}\label{listing:calculate_expected_results}

Die Ausführung des Programms erfolgt durch einen \textit{GET-Aufruf}, s. Abbildung \vref{listing:get_result}. Dieser wird mit den Parametern versehen, die für den bestehenden Anwendungsfall notwendig sind. Der Darlehensverlauf Controller empfängt diesen GET-Befehl mit den dazugehörigen Parametern, und berechnet das Ergebnis: In diesem Fall eine HTML Seite. Dazu gehören auch die zugehörigen Controller-Instanzvariablen, die für den HTML Output maßgeblich sind.\\

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=95, lastline=96]{\string"../ozbapp/spec/controllers/DarlehensverlaufController_spec\string".rb}\label{listing:get_result}

Um nun auf das Ergebnis zugreifen zu können, um die vom Controller berechneten Werte mit den erwarteten Werten zu vergleichen, wird mit Hilfe des \textit{assigns-Befehl} auf die gewünschten Instanzvariablen zugegriffen. Dies zeigt Abbildung \vref{listing:compare__results}.\\

\lstinputlisting[language=Ruby, frame=single, caption=Factory der Adressen, tabsize=2, flexiblecolumns=true, captionpos=b, firstline=96, lastline=113]{\string"../ozbapp/spec/controllers/DarlehensverlaufController_spec\string".rb}\label{listing:compare__results}

% Auswertung der bisherigen manuellen Tests
\section{Auswertung}
Die Auswertung befindet sich im Anhang Kapitel \vref{sec:appendix}.

\chapter{Features}
\section{PaperTrail - Historisierung}
Im Laufe der Projektarbeit ist uns eine Alternative zu der damalig bestehenden Historisierungsfunktion bekannt geworden. Es handelt sich dabei um ein RoR Gem \textit{PaperTrail}. Die Webseite \url{https://github.com/airblade/paper_trail} liefert nähere Details zu diesem Gem. Zusammenfassend löst dieses Gem  Auditing und/oder Versionierung in einer sehr eleganten und einfach anzuwendenden Weise. Es erzeugt dazu eine weitere, große Tabelle, in der jede Datensatzänderung einen Platz findet. Die Datensätze können mit vom Entwickler angereicherten Informationen versehen werden, um weiteren Anforderungen gerecht zu werden. Das Verhalten von PaperTrail lässt sich durch den Entwickler prima steuern, z.B. können nur bestimmte Attribute historisiert werden. Außerdem lassen sich Datensätze zu jeder vorherigen Version zurücksetzen, oder gelöschte wiederherstellen.\\
Für eine Evaluierung wurde probeweise dieses Gem an diesem Projekt ausprobiert. Wir sind zu dem Ergebnis gekommen, dass es sich prima für die gedachten Zwecke eignen würde. Allerdings kam dieses Gem noch nicht zum Einsatz, daher wurde wie schon in einem früheren beschrieben, die Historisierung in ein eigenständiges Modul ausgelagert und nicht komplett durch dieses Gem ersetzt.


\section{Deployment E-Mail Benachrichtigung}
Im Zuge der Modellierung eines Deploymentprozesses, wurde auch ein Skript geschrieben, das den Beteiligten eine E-Mail zusendet, sobald eine neue Version erfolgreich auf dem Alotech Server deployed wurde. Das Skript ist gut kommentiert, daher verweisen wir für technische Details auf das Skript selbst: Capify Skript: \glqq cap\_notify.rb\grqq. Zu finden ist es im Anhang, s. \vref{listing:capify_notify}.

\chapter{Ergebnis und Ausblick}
\section{Ergebnis}
Zum Abschluss dieser Projektarbeit werden die Ergebnisse zusammengefasst. 

\subsection{Bugfixes}
Zu Beginn der Projektarbeit wurden ein paar Fehler bekannt gegeben, die Anwendungskritisch sind. In Kapitel 4 wurden diese Fehler behandelt und weitere größere Umbauarbeiten genannt, die zu Verbesserungen der Anwendung in den Punkten Wartbarkeit und Fehleranfälligkeit führten.

\subsection{Deployment Prozess}
Jede Gruppe hatte bislang ihre eigenen Strategien, die Anwendung auf einem Webserver zu deployen. Dies führte zu Missverständnissen und hat viel Zeit gekostet. Damit dies in Zukunft nicht mehr passiert, wurde ein kompletter Deployment Prozess beschrieben und implementiert, der auch eine Systembeschreibung des Alvotech-Servers beinhaltet.

\subsection{Datenmodell}
Im Laufe der Projektarbeit ist ein solides und fixiertes Datenmodell entstanden, welches nun als endgültige Basis den zukünftigen Gruppen dienen wird.

\subsection{Unit Tests}
Es sind eine große Anzahl an Unit Tests entstanden, die Absichern, dass das nun festgelegte Datenmodell technisch und fachlich korrekt implementiert ist. 

\subsection{Refactoring}
Im Zuge der Umbauarbeiten des Datenmodells, wurden auch die Tests angepasst. Dies hat auch zur Folge, dass alle Modelle an das nun fixierte Datenmodell angepasst werden mussten. Darüber hinaus wurde sehr auf eine einheitliche Implementierungsweise geachtet. Wenn das Datenmodell Veränderungen erfahren hat, so muss auch das Migrationstool angepasst werden. Hierbei wurden auch Sonderfälle, wie fehlende Bankleitzahlen, E-Mail Adressen und weiteres beachtet.

\subsection{Best Practices, Einführung Feature Tests}
Ein weiteres Ziel dieser Projektarbeit, die Einführung des TDD, wurde erfolgreich umgesetzt. Den zukünftigen Gruppen stehen bereits evaluierte Lösungen bereit, sowohl die konkrete Test-Implementierung als auch die Tools, damit die weitere Entwicklung reibungslos von statten gehen wird.\\
Darüber hinaus wurde neben den Unit Tests auch ein Feature Test implementiert, der auf bereits in Testberichten dokumentierten Anwendungsfällen basiert und eine automatisierte Abhandlung der manuellen Tests aufzeigt.

\section{Ausblick}
Beim abschließenden Kollogium wurden die weiteren Schritte zusammen besprochen. Es sollen weitere Tests entstehen, die den noch verbliebenen Teil der ungetesteten Modelle abdecken. Darüber hinaus wurde beschlossen, dass nun eingeführte Vorgehensmodell für die weitere Entwicklung strikt einzubehalten. Somit sollen in Zukunft vorerst keine weiteren Funktionalitäten implementiert werden, sondern die bisherigen durch Feature Tests auf ihre korrekte Funktionalität in sowohl technischer als auch fachlicher Hinsicht überprüft und ggf. korrigiert werden. Außerdem wurde der Einsatz des Gems PaperTrail erwogen.\\

Zum Abschluss bedanken wir uns recht herzlich für die gute Zusammenarbeit mit Herrn Kienle, Herrn Weltke, Herrn Kleinert und Herrn Schaefer.

\clearpage
\appendix
\chapter{Anhang}\label{sec:appendix}
\section{Test-Driven-Development Präsentation}
\includepdf[pages={1-25}]{TDDPresentation.pdf}
\clearpage
\section{Definition der o/ZB Attribute}
\label{chapter:ozb_attribute}
\includepdf[pages=-, landscape=true]{Media/definition_ozb_attribute.pdf}

\clearpage
\begin{lstlisting}[language=Ruby, frame=single, caption=notify.rb, tabsize=2, flexiblecolumns=true, captionpos=b]
require "action_mailer"
require "tlsmail" 

ActionMailer::Base.delivery_method = :smtp
ActionMailer::Base.smtp_settings = {
  :enable_starttls_auto => true,
  :tls => true,
  :address => "smtp.gmail.com",
  :port => 587,
  :domain => "googlemail.com",
  :authentication => "plain",
  :user_name => "",
  :password => ""
}
 
class Notifier < ActionMailer::Base
  default :from => "E-MAIL adress"
  
  def deploy_notification(cap_vars)
    now = Time.now
    msg = "Performed a deploy operation on #{now.strftime("%m/%d/%Y")} at #{now.strftime("%I:%M %p")} to #{cap_vars.host}"
    
    mail(:to => cap_vars.notify_emails, 
         :subject => "Deployed #{cap_vars.application} to #{cap_vars.stage}") do |format|
      format.text { render :text => msg}
      format.html { render :text => "<p>" + msg + "<\p>"}
    end
  end
end
\end{lstlisting}\label{listing:capify_notify}

\clearpage
\begin{lstlisting}[language=Ruby, frame=single, caption=deploy.rb, tabsize=2, flexiblecolumns=true, captionpos=b]
# cap email notifier
load "config/cap_notify.rb"

set :application, "ozbapp"

server "188.64.45.50", :web, :app, :db, :primary => true

set :scm, "git"
set :repository, "https://github.com/Avenel/FirstApp.git"
set :branch, "master"

set :user, "ozbapp"
set :deploy_to, "/home/#{user}/apps/#{application}"
set :deploy_via, :remote_cache
set :use_sudo, false
set :host, "ozbapp.mooo.com"
set :stage, "ozbapp.mooo.com"

require 'net/ssh/proxy/socks5'

# Setup email notification
set :notify_emails, ["TKienle@t-online.de", "frank.schaefer@hs-karlsruhe.de", "stefan.welte@stud.uni-karlsruhe.de"]

namespace :deploy do

	desc "Tell Passenger to restart the app."
	task :restart do
		run "mkdir #{current_path}/ozbapp/tmp"
		run "cat > #{current_path}/ozbapp/tmp/restart.txt"
		run "touch #{current_path}/ozbapp/tmp/restart.txt"
	end

	desc "Renew SymLink"
	task :renew_symlink do
		run "rm /home/ozbapp/ozbapp"
		run "ln -s /home/ozbapp/apps/ozbapp/current/ozbapp /home/ozbapp/ozbapp"
	end

	desc "Renew create_tables.txt"
	task :renew_create_tables do
		run "rm /home/ozbapp/create_tables.txt"
		run "cp -f /home/ozbapp/apps/ozbapp/current/tools/create_tables.txt /home/ozbapp/create_tables.txt"
	end

	# Create task to send a notification
	desc "Send email notification"
	task :send_notification do
		Notifier.deploy_notification(self).deliver 
	end

end

after 'deploy:update_code', 'deploy:renew_symlink'
after :deploy, 'deploy:renew_create_tables'
after :deploy, 'deploy:send_notification'
\end{lstlisting}\label{listing:capify_deploy}

\newpage
%\addcontentsline{toc}{chapter}{Abbildungsverzeichnis}
\listoffigures

\newpage
%\addcontentsline{toc}{chapter}{Tabellenverzeichnis}
\listoftables

\newpage
%\addcontentsline{toc}{chapter}{Listingsverzeichnis}
\lstlistoflistings

\newpage
%\addcontentsline{toc}{chapter}{Literatur}
\bibliography{sources}

\end{document}

